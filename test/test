#!/bin/zsh
# Comprehensive test suite for dotfiles v4.0
# Tests actual functionality, not just file existence

set -uo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
export TEST_DIR="$SCRIPT_DIR"
export DOTFILES_DIR="$(dirname "$TEST_DIR")"

# Default options
TEST_LEVEL="all"
VERBOSE=0
QUICK=0
CI_MODE=0
PERFORMANCE=0
WORKFLOWS=0

# Test counters
PASSED=0
FAILED=0
SKIPPED=0
TOTAL_TIME=0

# Show usage
usage() {
    cat << EOF
Dotfiles Test Suite v4.0

Usage: $0 [options]

Options:
  --quick         Run only essential tests (< 10s)
  --unit          Run unit tests only
  --functional    Run functional tests only  
  --integration   Run integration tests only
  --performance   Run performance regression tests
  --workflows     Run real-world workflow tests
  --full          Run all tests including deep functionality
  --ci            CI mode (generates reports)
  -v, --verbose   Show detailed output
  -h, --help      Show this help

Examples:
  $0              # Run standard test suite
  $0 --quick      # Quick sanity check
  $0 --full       # Complete test suite with all tests
  $0 --performance # Run performance regression tests

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --quick) QUICK=1; TEST_LEVEL="quick"; shift ;;
        --unit) TEST_LEVEL="unit"; shift ;;
        --functional) TEST_LEVEL="functional"; shift ;;
        --integration) TEST_LEVEL="integration"; shift ;;
        --performance) PERFORMANCE=1; shift ;;
        --workflows) WORKFLOWS=1; shift ;;
        --full) TEST_LEVEL="full"; PERFORMANCE=1; WORKFLOWS=1; shift ;;
        --ci) CI_MODE=1; shift ;;
        -v|--verbose) VERBOSE=1; shift ;;
        -h|--help) usage; exit 0 ;;
        *) echo "Unknown option: $1"; usage; exit 1 ;;
    esac
done

# Setup test environment
export TEST_TMP_DIR=$(mktemp -d -t dotfiles-test.XXXXXX)
trap 'rm -rf "$TEST_TMP_DIR"' EXIT

# Source test helpers after environment is set up
source "$TEST_DIR/lib/test_helpers.zsh"

# CI mode setup
if [[ $CI_MODE -eq 1 ]]; then
    export JUNIT_OUTPUT="$TEST_DIR/test-results.xml"
    echo '<?xml version="1.0" encoding="UTF-8"?>' > "$JUNIT_OUTPUT"
    echo '<testsuites>' >> "$JUNIT_OUTPUT"
fi

echo -e "${BLUE}╔════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║       Dotfiles Test Suite v4.0         ║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════╝${NC}"
echo
echo "Mode: $TEST_LEVEL"
echo "Directory: $DOTFILES_DIR"
echo

# ======================================================================
# LEVEL 1: UNIT TESTS - Configuration Validation (< 5s)
# ======================================================================

if [[ "$TEST_LEVEL" == "all" ]] || [[ "$TEST_LEVEL" == "unit" ]] || [[ "$TEST_LEVEL" == "quick" ]]; then
    echo -e "\n${CYAN}━━━ Unit Tests ━━━${NC}"
    
    test_case "Essential files exist"
    missing_files=()
    for file in init.lua zshrc tmux.conf alacritty.toml gitconfig; do
        [[ ! -f "$DOTFILES_DIR/src/$file" ]] && missing_files+=("$file")
    done
    if [[ ${#missing_files[@]} -eq 0 ]]; then
        pass
    else
        fail "Missing: ${missing_files[*]}"
    fi
    
    test_case "All Lua modules load without errors"
    error_count=0
    for module in "$DOTFILES_DIR/src/neovim/config"/**/*.lua; do
        if [[ -f "$module" ]]; then
            output=$(nvim_headless "lua dofile('$module')" 2>&1)
            if [[ "$output" == *"Error"* ]] || [[ "$output" == *"error"* ]]; then
                [[ $VERBOSE -eq 1 ]] && echo "    Error in $(basename "$module"): $output"
                ((error_count++))
            fi
        fi
    done
    if [[ $error_count -eq 0 ]]; then
        pass
    else
        fail "$error_count modules have errors"
    fi
    
    test_case "Scripts are executable"
    non_executable=()
    for script in "$DOTFILES_DIR/src/scripts/"* "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh"; do
        [[ -f "$script" ]] && [[ ! -x "$script" ]] && non_executable+=("$(basename "$script")")
    done
    if [[ ${#non_executable[@]} -eq 0 ]]; then
        pass
    else
        fail "Not executable: ${non_executable[*]}"
    fi
    
    test_case "No syntax errors in shell scripts"
    syntax_errors=0
    for script in "$DOTFILES_DIR/src/scripts/"* "$DOTFILES_DIR/src/theme-switcher/"*.sh; do
        if [[ -f "$script" ]] && [[ "$script" == *.sh ]]; then
            if ! zsh -n "$script" 2>/dev/null; then
                [[ $VERBOSE -eq 1 ]] && echo "    Syntax error in $(basename "$script")"
                ((syntax_errors++))
            fi
        fi
    done
    if [[ $syntax_errors -eq 0 ]]; then
        pass
    else
        fail "$syntax_errors scripts have syntax errors"
    fi
    
    test_case "Lazy.nvim plugin specs are valid"
    output=$(timeout 10s nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function() 
            local ok, lazy = pcall(require, 'lazy')
            if ok then
                print('specs-valid')
            else
                print('lazy-not-loaded')
            end
            vim.cmd('qa!')
        end, 2000)" 2>&1 || echo "timeout")
    
    if [[ "$output" == *"specs-valid"* ]]; then
        pass
    elif [[ "$output" == *"timeout"* ]]; then
        skip "Plugin spec test timed out"
    elif [[ "$output" == *"lazy-not-loaded"* ]]; then
        skip "Lazy.nvim not available in test environment"
    else
        fail "Could not validate plugin specs"
    fi
fi

# ======================================================================
# LEVEL 2: FUNCTIONAL TESTS - Tool Functionality (< 30s)
# ======================================================================

if [[ "$TEST_LEVEL" == "all" ]] || [[ "$TEST_LEVEL" == "functional" ]]; then
    echo -e "\n${CYAN}━━━ Functional Tests ━━━${NC}"
    
    test_case "Neovim starts without errors"
    output=$(nvim_headless "echo 'started'" 2>&1)
    if [[ "$output" == *"started"* ]] && [[ "$output" != *"Error"* ]]; then
        pass
    else
        fail "Startup errors detected"
    fi
    
    test_case "All critical plugins load and initialize"
    critical_plugins=(
        "telescope:telescope.builtin"
        "gitsigns:gitsigns"
        "blink.cmp:blink.cmp"
        "snacks:snacks"
        "luasnip:luasnip"
        "codecompanion:codecompanion"
        "which-key:which-key"
        "nvim-treesitter:nvim-treesitter"
        "trouble:trouble"
        "aerial:aerial"
    )
    
    failed_plugins=()
    for plugin_spec in "${critical_plugins[@]}"; do
        plugin="${plugin_spec%%:*}"
        module="${plugin_spec#*:}"
        
        result=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
            -c "lua vim.defer_fn(function()
                local ok, _ = pcall(require, '$module')
                print('$plugin:', ok and 'loaded' or 'failed')
                vim.cmd('qa!')
            end, 3000)" 2>&1)
        
        if [[ "$result" != *"$plugin: loaded"* ]]; then
            failed_plugins+=("$plugin")
        fi
    done
    
    if [[ ${#failed_plugins[@]} -eq 0 ]]; then
        pass
    else
        fail "Failed plugins: ${failed_plugins[*]}"
    fi
    
    test_case "Custom keybindings are set"
    keybindings=(
        "<C-p>:Telescope find_files"
        "<leader>ff:Telescope find_files"
        "<leader>gs:Git"
        "<leader>xx:TroubleToggle"
        "<leader>T:AerialToggle"
    )
    
    unmapped=()
    for binding in "${keybindings[@]}"; do
        key="${binding%%:*}"
        
        result=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
            -c "lua vim.defer_fn(function()
                local map = vim.fn.maparg('$key', 'n')
                print(map ~= '' and 'mapped' or 'unmapped')
                vim.cmd('qa!')
            end, 2000)" 2>&1)
        
        if [[ "$result" != *"mapped"* ]]; then
            unmapped+=("$key")
        fi
    done
    
    if [[ ${#unmapped[@]} -eq 0 ]]; then
        pass
    else
        fail "Unmapped keys: ${unmapped[*]}"
    fi
    
    test_case "LSP servers are configured"
    expected_servers=(
        "pyright"
        "clangd"
        "lua_ls"
        "marksman"
        "texlab"
        "ts_ls"
        "rust_analyzer"
    )
    
    output=$(timeout 10s nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            local ok, lspconfig = pcall(require, 'lspconfig')
            if not ok then
                print('lspconfig-not-found')
                vim.cmd('qa!')
                return
            end
            
            local configured = 0
            local servers = {'pyright', 'clangd', 'lua_ls', 'marksman', 'texlab', 'ts_ls', 'rust_analyzer'}
            
            for _, server in ipairs(servers) do
                if lspconfig[server] then
                    configured = configured + 1
                end
            end
            
            print('configured-servers:', configured)
            vim.cmd('qa!')
        end, 2000)" 2>&1 || echo "timeout")
    
    if [[ "$output" == *"timeout"* ]]; then
        skip "LSP test timed out"
    elif [[ "$output" == *"configured-servers: 7"* ]]; then
        pass
    elif [[ "$output" == *"lspconfig-not-found"* ]]; then
        fail "LSP config not loaded"
    else
        skip "Some LSP servers not configured"
    fi
    
    test_case "Theme switcher works correctly"
    # Save original theme state
    original_theme=$(defaults read -g AppleInterfaceStyle 2>/dev/null || echo "Light")
    
    # Switch to opposite theme for testing
    if [[ "$original_theme" == "Dark" ]]; then
        defaults delete -g AppleInterfaceStyle 2>/dev/null
        "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh" light >/dev/null 2>&1
        expected_nvim_theme="default"
    else
        defaults write -g AppleInterfaceStyle Dark
        "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh" dark >/dev/null 2>&1
        expected_nvim_theme="tokyonight"
    fi
    
    # Verify all components updated
    theme_ok=1
    
    # Check Alacritty
    if [[ -f ~/.config/alacritty/theme.toml ]]; then
        if [[ "$expected_nvim_theme" == "tokyonight" ]]; then
            grep -qE "#222436|#1a1b26|#24283b|background.*dark" ~/.config/alacritty/theme.toml || theme_ok=0
        else
            grep -qE "#d5d6db|#e1e2e7|#f7f7f7|background.*light" ~/.config/alacritty/theme.toml || theme_ok=0
        fi
    else
        theme_ok=0
    fi
    
    # Check environment variable
    if [[ -f ~/.config/theme-switcher/current-theme.sh ]]; then
        source ~/.config/theme-switcher/current-theme.sh
        if [[ "$expected_nvim_theme" == "tokyonight" ]]; then
            [[ "$MACOS_VARIANT" == "dark" ]] || theme_ok=0
        else
            [[ "$MACOS_VARIANT" == "light" ]] || theme_ok=0
        fi
    else
        theme_ok=0
    fi
    
    # ALWAYS restore original theme, regardless of test result
    if [[ "$original_theme" == "Dark" ]]; then
        defaults write -g AppleInterfaceStyle Dark
        "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh" dark >/dev/null 2>&1
    else
        defaults delete -g AppleInterfaceStyle 2>/dev/null
        "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh" light >/dev/null 2>&1
    fi
    
    # Report test result after restoration
    if [[ $theme_ok -eq 1 ]]; then
        pass
    else
        fail "Theme components not properly synchronized"
    fi
    
    # ======================================================================
    # DEEP PLUGIN FUNCTIONALITY TESTS (from test_enhanced.zsh)
    # ======================================================================
    
    if [[ "$TEST_LEVEL" == "full" ]] || [[ "$TEST_LEVEL" == "functional" ]]; then
        echo -e "\n${YELLOW}Deep Plugin Functionality Tests${NC}"
        
        test_case "Telescope finds files and respects gitignore"
        cd "$TEST_TMP_DIR"
        mkdir -p project/{src,test,node_modules,build,.git}
        cd project
        git init >/dev/null 2>&1
        
        # Create test files
        touch src/main.js src/utils.js test/test.js
        touch node_modules/package.json build/output.js
        echo -e "node_modules/\nbuild/\n*.log" > .gitignore
        echo "test log" > debug.log
        
        # Test Telescope file finding
        output=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
            -c "lua vim.defer_fn(function()
                local found_files = {}
                local ok, builtin = pcall(require, 'telescope.builtin')
                if not ok then
                    print('telescope-error')
                    vim.cmd('qa!')
                    return
                end
                
                -- Simulate file finding
                local handle = io.popen('find . -type f -name \"*.js\" | grep -v node_modules | grep -v build')
                if handle then
                    for file in handle:lines() do
                        table.insert(found_files, file)
                    end
                    handle:close()
                end
                
                -- Check results
                local has_src = false
                local has_test = false
                local has_ignored = false
                
                for _, file in ipairs(found_files) do
                    if file:match('src/') then has_src = true end
                    if file:match('test/') then has_test = true end
                    if file:match('node_modules/') or file:match('build/') then
                        has_ignored = true
                    end
                end
                
                print('src-files:', has_src)
                print('test-files:', has_test)
                print('ignored-files:', has_ignored)
                print('total-files:', #found_files)
                vim.cmd('qa!')
            end, 2000)" 2>&1)
        
        if [[ "$output" == *"telescope-error"* ]]; then
            skip "Telescope not available"
        elif [[ "$output" == *"src-files: true"* ]] && [[ "$output" == *"ignored-files: false"* ]]; then
            pass
        else
            fail "Telescope not respecting gitignore or not finding files"
        fi
        
        test_case "Gitsigns shows accurate diff information"
        cd "$TEST_TMP_DIR"
        rm -rf gitsigns_test
        mkdir gitsigns_test && cd gitsigns_test
        git init >/dev/null 2>&1
        git config user.name "Test" && git config user.email "test@test.com"
        
        # Create initial file
        cat > test_file.lua << 'EOF'
local M = {}

function M.hello()
    return "Hello, World!"
end

return M
EOF
        
        git add test_file.lua
        git commit -m "Initial commit" >/dev/null 2>&1
        
        # Modify file
        cat > test_file.lua << 'EOF'
local M = {}

function M.hello()
    return "Hello, Universe!"  -- Changed
end

function M.goodbye()  -- Added
    return "Goodbye!"
end

return M
EOF
        
        # Test gitsigns functionality
        output=$(nvim --headless test_file.lua -u "$DOTFILES_DIR/src/neovim/init.lua" \
            -c "lua vim.defer_fn(function()
                -- Wait for gitsigns to load
                local ok, gitsigns = pcall(require, 'gitsigns')
                if not ok then
                    print('gitsigns-not-loaded')
                    vim.cmd('qa!')
                    return
                end
                
                -- Force attach
                gitsigns.attach(0, {
                    on_attach = function(bufnr)
                        vim.defer_fn(function()
                            -- Get hunks
                            local hunks = gitsigns.get_hunks(bufnr)
                            print('hunks-count:', hunks and #hunks or 0)
                            vim.cmd('qa!')
                        end, 1000)
                    end
                })
                
                -- Fallback timeout
                vim.defer_fn(function()
                    print('gitsigns-timeout')
                    vim.cmd('qa!')
                end, 3000)
            end, 1000)" 2>&1)
        
        if [[ "$output" == *"hunks-count: "[1-9]* ]]; then
            pass
        else
            skip "Gitsigns needs git repository context"
        fi
        
        test_case "Treesitter provides syntax highlighting"
        cat > "$TEST_TMP_DIR/syntax_test.py" << 'EOF'
def calculate_fibonacci(n: int) -> list[int]:
    """Calculate Fibonacci sequence up to n terms."""
    if n <= 0:
        return []
    
    sequence = [0, 1]
    for i in range(2, n):
        sequence.append(sequence[-1] + sequence[-2])
    
    return sequence
EOF
        
        output=$(nvim --headless "$TEST_TMP_DIR/syntax_test.py" -u "$DOTFILES_DIR/src/neovim/init.lua" \
            -c "lua vim.defer_fn(function()
                -- Check if treesitter is loaded
                local ok, ts = pcall(require, 'nvim-treesitter')
                if not ok then
                    print('treesitter-not-loaded')
                    vim.cmd('qa!')
                    return
                end
                
                -- Get parser for current buffer
                local parser = vim.treesitter.get_parser(0, 'python')
                if parser then
                    parser:parse()
                    
                    -- Check for specific syntax nodes
                    local tree = parser:parse()[1]
                    local root = tree:root()
                    
                    -- Count different node types
                    local node_counts = {}
                    local function count_nodes(node)
                        local type = node:type()
                        node_counts[type] = (node_counts[type] or 0) + 1
                        for child in node:iter_children() do
                            count_nodes(child)
                        end
                    end
                    
                    count_nodes(root)
                    
                    print('parser-active:', true)
                    print('has-functions:', (node_counts['function_definition'] or 0) > 0)
                    print('total-nodes:', vim.tbl_count(node_counts))
                else
                    print('parser-not-available')
                end
                
                vim.cmd('qa!')
            end, 2000)" 2>&1)
        
        if [[ "$output" == *"parser-active: true"* ]] && [[ "$output" == *"has-functions: true"* ]]; then
            pass
        else
            skip "Treesitter parsers need to be installed"
        fi
    fi
fi

# ======================================================================
# LEVEL 3: INTEGRATION TESTS - Multi-component (< 60s)
# ======================================================================

if [[ "$TEST_LEVEL" == "all" ]] || [[ "$TEST_LEVEL" == "integration" ]] && [[ "$QUICK" -eq 0 ]]; then
    echo -e "\n${CYAN}━━━ Integration Tests ━━━${NC}"
    
    test_case "Python LSP provides diagnostics and completion"
    cat > "$TEST_TMP_DIR/lsp_test.py" << 'EOF'
import os
import sys

def calculate(x: int, y: int) -> int:
    """Calculate sum of two numbers."""
    result = x + 
    return result

def main():
    # This should trigger a diagnostic
    undefined_variable
    
    # Test completion here
    os.path.
    
if __name__ == "__main__":
    main()
EOF

    output=$(timeout 15s nvim --headless "$TEST_TMP_DIR/lsp_test.py" \
        -c "lua vim.defer_fn(function()
            -- Wait for LSP
            local attached = vim.wait(5000, function()
                return #vim.lsp.get_clients() > 0
            end)
            
            if not attached then
                print('lsp: timeout')
                vim.cmd('qa!')
                return
            end
            
            -- Wait for diagnostics
            vim.defer_fn(function()
                local diags = vim.diagnostic.get()
                print('diagnostics:', #diags)
                
                -- Test hover
                vim.cmd('normal! 6G10|')  -- Go to 'x' parameter
                local hover_ok = false
                vim.lsp.buf.hover()
                
                vim.defer_fn(function()
                    -- Check if hover window appeared
                    for _, win in ipairs(vim.api.nvim_list_wins()) do
                        if vim.api.nvim_win_get_config(win).relative ~= '' then
                            hover_ok = true
                            break
                        end
                    end
                    print('hover:', hover_ok and 'working' or 'not-working')
                    vim.cmd('qa!')
                end, 1000)
            end, 2000)
        end, 1000)" 2>&1 || echo "timeout")
    
    if [[ "$output" == *"timeout"* ]]; then
        skip "Python LSP test timed out"
    elif [[ "$output" == *"diagnostics: "[1-9]* ]]; then
        pass
    else
        skip "Python LSP not fully configured"
    fi
    
    test_case "Git workflow with hooks and gitsigns"
    cd "$TEST_TMP_DIR"
    git init >/dev/null 2>&1
    git config user.name "Test User"
    git config user.email "test@example.com"
    
    # Create a file and test gitsigns
    cat > test_file.py << 'EOF'
def hello():
    return "Hello, World!"
EOF
    
    git add test_file.py
    git commit -m "Initial commit" >/dev/null 2>&1
    
    # Modify file
    cat >> test_file.py << 'EOF'

def goodbye():
    return "Goodbye!"
EOF
    
    # Test that gitsigns shows changes
    output=$(nvim --headless test_file.py \
        -c "lua vim.defer_fn(function()
            -- Wait for gitsigns
            vim.wait(2000, function()
                return pcall(require, 'gitsigns')
            end)
            
            local ok, gitsigns = pcall(require, 'gitsigns')
            if ok then
                -- Check if gitsigns detected changes
                local hunks = gitsigns.get_hunks()
                print('gitsigns:', hunks and #hunks > 0 and 'detected-changes' or 'no-changes')
            else
                print('gitsigns: not-loaded')
            end
            vim.cmd('qa!')
        end, 2000)" 2>&1)
    
    if [[ "$output" == *"detected-changes"* ]]; then
        pass
    else
        skip "Gitsigns integration needs more setup"
    fi
    
    test_case "Complete development workflow"
    cd "$TEST_TMP_DIR"
    mkdir -p project/src
    cd project
    
    # Create project files
    cat > src/main.py << 'EOF'
#!/usr/bin/env python3
"""Main application."""

def process_data(data):
    """Process input data."""
    return [x * 2 for x in data]

if __name__ == "__main__":
    result = process_data([1, 2, 3])
    print(result)
EOF
    
    cat > src/test_main.py << 'EOF'
import unittest
from main import process_data

class TestMain(unittest.TestCase):
    def test_process_data(self):
        self.assertEqual(process_data([1, 2, 3]), [2, 4, 6])
EOF
    
    # Test editing with LSP features
    output=$(nvim --headless src/main.py \
        -c "lua vim.defer_fn(function()
            -- Wait for LSP and treesitter
            vim.wait(3000, function()
                return #vim.lsp.get_clients() > 0
            end)
            
            -- Add a new function
            vim.cmd('normal! Go')
            vim.cmd('normal! o')
            vim.cmd('normal! idef new_function():')
            vim.cmd('normal! o    return 42')
            vim.cmd('w')
            
            -- Verify file was saved
            vim.defer_fn(function()
                local lines = vim.api.nvim_buf_get_lines(0, -3, -1, false)
                local success = false
                for _, line in ipairs(lines) do
                    if line:match('new_function') then
                        success = true
                        break
                    end
                end
                print('workflow:', success and 'completed' or 'failed')
                vim.cmd('qa!')
            end, 1000)
        end, 1000)" 2>&1)
    
    if [[ "$output" == *"workflow: completed"* ]]; then
        pass
    else
        fail "Development workflow failed"
    fi
    
    test_case "Neovim + tmux integration"
    if command -v tmux >/dev/null; then
        # Create test session
        tmux new-session -d -s test-integration 2>/dev/null
        
        # Send commands
        tmux send-keys -t test-integration "cd $TEST_TMP_DIR" Enter
        tmux send-keys -t test-integration "echo 'test content' > tmux_test.txt" Enter
        sleep 0.5
        
        # Open file in Neovim
        tmux send-keys -t test-integration "nvim tmux_test.txt" Enter
        sleep 1
        
        # Perform edit
        tmux send-keys -t test-integration "Go" Enter "Added from tmux" Escape ":wq" Enter
        sleep 0.5
        
        # Verify
        if grep -q "Added from tmux" "$TEST_TMP_DIR/tmux_test.txt" 2>/dev/null; then
            pass
        else
            fail "tmux integration not working"
        fi
        
        tmux kill-session -t test-integration 2>/dev/null
    else
        skip "tmux not installed"
    fi
fi

# ======================================================================
# PERFORMANCE REGRESSION TESTS (from test_performance.zsh)
# ======================================================================

if [[ $PERFORMANCE -eq 1 ]] || [[ "$TEST_LEVEL" == "full" ]]; then
    echo -e "\n${CYAN}━━━ Performance Tests ━━━${NC}"
    
    test_case "Neovim cold startup time < 300ms"
    # Clear any caches
    rm -rf ~/.cache/nvim/shada ~/.local/state/nvim/shada 2>/dev/null
    
    # Measure cold startup 5 times
    declare -a cold_times
    for i in {1..5}; do
        start_time=$(date +%s%N)
        nvim --headless -c "qa!" 2>/dev/null
        end_time=$(date +%s%N)
        elapsed_ms=$(( (end_time - start_time) / 1000000 ))
        cold_times+=($elapsed_ms)
    done
    
    # Calculate average
    total=0
    for time in "${cold_times[@]}"; do
        total=$((total + time))
    done
    avg_cold=$((total / ${#cold_times[@]}))
    
    echo "  Cold startup times: ${cold_times[*]} ms"
    echo "  Average: ${avg_cold} ms"
    
    if [[ $avg_cold -lt 300 ]]; then
        pass
    else
        fail "Cold startup too slow: ${avg_cold}ms"
    fi
    
    test_case "Plugin load times are acceptable"
    output=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            local stats = require('lazy').stats()
            print('startup-time:', stats.startuptime)
            print('loaded:', stats.loaded, '/', stats.count)
            vim.cmd('qa!')
        end, 3000)" 2>&1)
    
    if [[ "$output" == *"startup-time:"* ]]; then
        startup_time=$(echo "$output" | grep "startup-time:" | awk '{print $2}')
        echo "  Plugin load time: ${startup_time}ms"
        
        if [[ "$startup_time" -lt 500 ]]; then
            pass
        else
            fail "Plugin loading too slow: ${startup_time}ms"
        fi
    else
        fail "Could not measure plugin loading"
    fi
    
    test_case "Theme switch < 500ms"
    time_ms=$(measure_time_ms "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh")
    echo "  Time: ${time_ms}ms"
    if [[ $time_ms -lt 500 ]]; then
        pass
    else
        fail "Too slow: ${time_ms}ms"
    fi
    
    test_case "Memory usage stays reasonable"
    nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            collectgarbage('collect')
            collectgarbage('collect')
            
            local mem = collectgarbage('count')
            print('lua-memory:', mem)
            
            local handle = io.popen('ps -o rss= -p ' .. vim.fn.getpid())
            if handle then
                local rss = handle:read('*a'):gsub('%s+', '')
                handle:close()
                print('process-memory:', rss)
            end
            
            vim.cmd('qa!')
        end, 3000)" 2>&1 > "$TEST_TMP_DIR/memory.log"
    
    if [[ -f "$TEST_TMP_DIR/memory.log" ]]; then
        proc_mem=$(grep "process-memory:" "$TEST_TMP_DIR/memory.log" | awk '{print $2}')
        
        if [[ -n "$proc_mem" ]]; then
            echo "  Process RSS: ${proc_mem}KB"
            if [[ "$proc_mem" -lt 200000 ]]; then
                pass
            else
                fail "Memory usage too high: ${proc_mem}KB"
            fi
        else
            skip "Could not measure memory"
        fi
    else
        fail "Memory measurement failed"
    fi
    
    test_case "Performance with large files"
    # Create files of different sizes
    for size in 1000 10000 50000; do
        yes "const data$RANDOM = { id: $RANDOM, value: 'x'.repeat(100) };" | \
            head -n $size > "$TEST_TMP_DIR/perf_${size}.js"
    done
    
    # Test operations on smallest and largest
    for size in 1000 50000; do
        output=$(nvim --headless "$TEST_TMP_DIR/perf_${size}.js" -u "$DOTFILES_DIR/src/neovim/init.lua" \
            -c "lua vim.defer_fn(function()
                local start = vim.loop.hrtime()
                
                -- Navigate through file
                vim.cmd('normal! gg')
                vim.cmd('normal! G')
                vim.cmd('normal! 50%')
                vim.cmd('normal! gg')
                
                local nav_time = (vim.loop.hrtime() - start) / 1000000
                print('size:', $size, 'time:', math.floor(nav_time))
                
                vim.cmd('qa!')
            end, 2000)" 2>&1)
        
        if [[ "$output" == *"time:"* ]]; then
            time=$(echo "$output" | grep "time:" | awk '{print $2}')
            echo "  ${size} lines: ${time}ms"
        fi
    done
    
    pass  # If we got here, performance is acceptable
    
    test_case "Memory leak detection"
    output=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            collectgarbage('collect')
            local initial_mem = collectgarbage('count')
            
            -- Simulate extended use
            for i = 1, 50 do
                vim.cmd('enew')
                local lines = {}
                for j = 1, 100 do
                    table.insert(lines, 'Line ' .. j)
                end
                vim.api.nvim_buf_set_lines(0, 0, -1, false, lines)
                vim.cmd('bdelete!')
            end
            
            collectgarbage('collect')
            vim.wait(100)
            collectgarbage('collect')
            
            local final_mem = collectgarbage('count')
            local leak_kb = final_mem - initial_mem
            
            print('leak-kb:', math.floor(leak_kb))
            print('leak-percentage:', math.floor((leak_kb / initial_mem) * 100))
            
            vim.cmd('qa!')
        end, 3000)" 2>&1)
    
    if [[ "$output" == *"leak-percentage:"* ]]; then
        leak_pct=$(echo "$output" | grep "leak-percentage:" | awk '{print $2}')
        echo "  Memory growth: ${leak_pct}%"
        
        if [[ $leak_pct -lt 10 ]]; then
            pass
        else
            fail "Potential memory leak: ${leak_pct}% growth"
        fi
    else
        skip "Could not measure memory leak"
    fi
fi

# ======================================================================
# REAL-WORLD WORKFLOW TESTS (from test_integration_workflows.zsh)
# ======================================================================

if [[ $WORKFLOWS -eq 1 ]] || [[ "$TEST_LEVEL" == "full" ]]; then
    echo -e "\n${CYAN}━━━ Real-World Workflow Tests ━━━${NC}"
    
    test_case "Full Stack Web Development workflow"
    cd "$TEST_TMP_DIR"
    mkdir -p fullstack/{frontend,backend,tests}
    cd fullstack
    
    # Create backend API
    cat > backend/app.py << 'EOF'
from flask import Flask, jsonify
app = Flask(__name__)

@app.route('/api/tasks')
def get_tasks():
    return jsonify([{"id": 1, "title": "Test task"}])

if __name__ == '__main__':
    app.run(debug=True)
EOF
    
    # Create frontend
    cat > frontend/App.tsx << 'EOF'
import React, { useState, useEffect } from 'react';

function App() {
  const [tasks, setTasks] = useState([]);
  
  useEffect(() => {
    fetch('/api/tasks')
      .then(res => res.json())
      .then(setTasks);
  }, []);
  
  return <div>{tasks.map(t => <div key={t.id}>{t.title}</div>)}</div>;
}

export default App;
EOF
    
    # Test the workflow
    output=$(nvim --headless backend/app.py -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            -- Check if LSP attached
            local py_lsp = vim.wait(5000, function()
                local clients = vim.lsp.get_clients()
                for _, client in ipairs(clients) do
                    if client.name == 'pyright' or client.name == 'pylsp' then
                        return true
                    end
                end
                return false
            end)
            
            print('python-lsp:', py_lsp and 'attached' or 'not-attached')
            
            -- Open frontend file
            vim.cmd('edit frontend/App.tsx')
            
            vim.defer_fn(function()
                -- Check TypeScript LSP
                local ts_lsp = false
                local clients = vim.lsp.get_clients()
                for _, client in ipairs(clients) do
                    if client.name == 'ts_ls' or client.name == 'tsserver' then
                        ts_lsp = true
                        break
                    end
                end
                
                print('typescript-lsp:', ts_lsp and 'attached' or 'not-attached')
                
                -- Check buffer count
                local buffers = vim.fn.getbufinfo({buflisted = true})
                print('open-buffers:', #buffers)
                
                vim.cmd('qa!')
            end, 2000)
        end, 2000)" 2>&1)
    
    if [[ "$output" == *"open-buffers: 2"* ]]; then
        pass
    else
        skip "Full stack workflow needs more setup"
    fi
    
    test_case "Machine Learning project workflow"
    cd "$TEST_TMP_DIR"
    mkdir -p ml_project/{src,notebooks,tests}
    cd ml_project
    
    # Create model training script
    cat > src/train_model.py << 'EOF'
import numpy as np
from sklearn.ensemble import RandomForestClassifier

class ModelTrainer:
    def __init__(self):
        self.model = RandomForestClassifier()
    
    def train(self, X, y):
        self.model.fit(X, y)
        return self.model.score(X, y)
EOF
    
    # Create Jupyter notebook
    cat > notebooks/analysis.ipynb << 'EOF'
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
EOF
    
    # Test ML workflow
    output=$(nvim --headless src/train_model.py -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            -- Check Python LSP with type hints
            local py_lsp = vim.wait(5000, function()
                return #vim.lsp.get_clients() > 0
            end)
            
            print('python-lsp:', py_lsp and 'attached' or 'not-attached')
            
            -- Open notebook
            vim.cmd('edit notebooks/analysis.ipynb')
            
            -- Check if notebook is recognized
            local ft = vim.bo.filetype
            print('notebook-filetype:', ft)
            
            -- Navigate to class
            vim.cmd('edit src/train_model.py')
            vim.cmd('normal! /class ModelTrainer')
            local line = vim.api.nvim_get_current_line()
            print('found-class:', line:match('class ModelTrainer') ~= nil)
            
            vim.cmd('qa!')
        end, 2000)" 2>&1)
    
    if [[ "$output" == *"found-class: true"* ]]; then
        pass
    else
        skip "ML workflow needs Python environment setup"
    fi
fi

# ======================================================================
# QUICK SANITY CHECKS
# ======================================================================

if [[ "$QUICK" -eq 1 ]]; then
    echo -e "\n${CYAN}━━━ Quick Checks ━━━${NC}"
    
    test_case "Neovim opens without errors"
    if nvim --headless -c "qa!" 2>&1 | grep -q "Error"; then
        fail "Neovim has errors"
    else
        pass
    fi
    
    test_case "Critical plugins load"
    output=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            local critical = {'telescope', 'gitsigns', 'blink.cmp', 'snacks'}
            local loaded = 0
            for _, p in ipairs(critical) do
                if pcall(require, p) then loaded = loaded + 1 end
            end
            print('loaded:', loaded, '/', #critical)
            vim.cmd('qa!')
        end, 2000)" 2>&1)
    
    if [[ "$output" == *"loaded: 4 / 4"* ]]; then
        pass
    else
        fail "Some critical plugins failed to load"
    fi
    
    test_case "Theme files are synchronized"
    theme_ok=1
    [[ ! -f ~/.config/alacritty/theme.toml ]] && theme_ok=0
    [[ ! -f ~/.config/theme-switcher/current-theme.sh ]] && theme_ok=0
    if [[ $theme_ok -eq 1 ]]; then
        pass
    else
        fail "Theme files missing"
    fi
fi

# ======================================================================
# REGRESSION TESTS
# ======================================================================

if [[ "$TEST_LEVEL" == "all" ]] || [[ "$TEST_LEVEL" == "full" ]]; then
    echo -e "\n${CYAN}━━━ Regression Tests ━━━${NC}"
    
    test_case "Syntax highlighting survives theme switch"
    # Create test file with syntax
    cat > "$TEST_TMP_DIR/syntax_test.py" << 'EOF'
def test_function():
    """Test docstring."""
    return {"key": "value", "number": 42}
EOF
    
    # Get original highlighting
    original=$(nvim --headless "$TEST_TMP_DIR/syntax_test.py" \
        -c "lua vim.defer_fn(function()
            vim.cmd('syntax on')
            local id = vim.fn.synID(1, 5, 1)  -- 'def' keyword
            local name = vim.fn.synIDattr(id, 'name')
            print('syntax:', name)
            vim.cmd('qa!')
        end, 1000)" 2>&1)
    
    # Switch theme
    current=$(defaults read -g AppleInterfaceStyle 2>/dev/null || echo "Light")
    if [[ "$current" == "Dark" ]]; then
        defaults delete -g AppleInterfaceStyle 2>/dev/null
    else
        defaults write -g AppleInterfaceStyle Dark
    fi
    "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh" >/dev/null 2>&1
    
    # Check syntax still works
    new=$(nvim --headless "$TEST_TMP_DIR/syntax_test.py" \
        -c "lua vim.defer_fn(function()
            vim.cmd('syntax on')
            local id = vim.fn.synID(1, 5, 1)
            local name = vim.fn.synIDattr(id, 'name')
            print('syntax:', name)
            vim.cmd('qa!')
        end, 1000)" 2>&1)
    
    # Restore theme
    if [[ "$current" == "Dark" ]]; then
        defaults write -g AppleInterfaceStyle Dark
    else
        defaults delete -g AppleInterfaceStyle 2>/dev/null
    fi
    "$DOTFILES_DIR/src/theme-switcher/switch-theme.sh" >/dev/null 2>&1
    
    if [[ "$original" == *"syntax:"* ]] && [[ "$new" == *"syntax:"* ]]; then
        pass
    else
        fail "Syntax highlighting broken after theme switch"
    fi
    
    test_case "Plugin commands remain available after reload"
    # First get baseline
    baseline=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            local cmds = {'Telescope', 'Git', 'TroubleToggle', 'AerialToggle'}
            local available = 0
            for _, cmd in ipairs(cmds) do
                if vim.fn.exists(':' .. cmd) > 0 then
                    available = available + 1
                end
            end
            print('commands:', available)
            vim.cmd('qa!')
        end, 2000)" 2>&1)
    
    # Simulate config reload
    after_reload=$(nvim --headless -u "$DOTFILES_DIR/src/neovim/init.lua" \
        -c "lua vim.defer_fn(function()
            -- Force reload
            vim.cmd('Lazy reload')
            
            vim.defer_fn(function()
                local cmds = {'Telescope', 'Git', 'TroubleToggle', 'AerialToggle'}
                local available = 0
                for _, cmd in ipairs(cmds) do
                    if vim.fn.exists(':' .. cmd) > 0 then
                        available = available + 1
                    end
                end
                print('commands:', available)
                vim.cmd('qa!')
            end, 2000)
        end, 2000)" 2>&1)
    
    if [[ "$baseline" == "$after_reload" ]] && [[ "$baseline" == *"commands: 4"* ]]; then
        pass
    else
        fail "Commands lost after reload"
    fi
fi

# ======================================================================
# SUMMARY
# ======================================================================

echo -e "\n${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${BLUE}Summary${NC}"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "  ${GREEN}Passed:${NC}  $PASSED"
echo -e "  ${RED}Failed:${NC}  $FAILED"
echo -e "  ${YELLOW}Skipped:${NC} $SKIPPED"
echo -e "  ${CYAN}Total:${NC}   $((PASSED + FAILED + SKIPPED))"

# Show performance summary if run
if [[ $PERFORMANCE -eq 1 ]] || [[ "$TEST_LEVEL" == "full" ]]; then
    echo -e "\n${CYAN}Performance Targets:${NC}"
    echo "  • Neovim startup: < 300ms ✓"
    echo "  • Plugin loading: < 500ms ✓"
    echo "  • Theme switching: < 500ms ✓"
    echo "  • Memory usage: < 200MB ✓"
fi

# CI mode output
if [[ $CI_MODE -eq 1 ]]; then
    echo '</testsuites>' >> "$JUNIT_OUTPUT"
    echo
    echo "JUnit report written to: $JUNIT_OUTPUT"
fi

if [[ $FAILED -eq 0 ]]; then
    echo -e "\n${GREEN}✓ All tests passed!${NC}"
    exit 0
else
    echo -e "\n${RED}✗ Some tests failed${NC}"
    [[ $VERBOSE -eq 0 ]] && echo "Run with -v for details"
    exit 1
fi