#!/usr/bin/env zsh
# Security Tests: Vulnerability and Security Scanning
# TEST_SIZE: medium

source "${TEST_DIR}/lib/framework.zsh"

test_no_hardcoded_secrets() {
    log "TRACE" "Scanning for hardcoded secrets"
    
    local secret_patterns=(
        "password\s*=\s*['\"][^'\"]+['\"]"
        "api[_-]?key\s*=\s*['\"][^'\"]+['\"]"
        "secret\s*=\s*['\"][^'\"]+['\"]"
        "token\s*=\s*['\"][^'\"]+['\"]"
        "aws_access_key_id"
        "aws_secret_access_key"
        "github_token"
        "private[_-]?key"
    )
    
    local violations=0
    
    for pattern in "${secret_patterns[@]}"; do
        local matches=$(grep -riE "$pattern" "$DOTFILES_DIR/src" \
            --exclude-dir=.git \
            --exclude-dir=.dotfiles.private \
            --exclude="*.md" \
            --exclude="*.txt" \
            --exclude="*.example" \
            2>/dev/null)
        
        if [[ -n "$matches" ]]; then
            log "ERROR" "Potential secret found with pattern: $pattern"
            log "DEBUG" "Matches: $matches"
            ((violations++))
        fi
    done
    
    [[ $violations -eq 0 ]] || return 1
    return 0
}

test_no_exposed_ssh_keys() {
    log "TRACE" "Checking for exposed SSH keys"
    
    local key_patterns=(
        "-----BEGIN RSA PRIVATE KEY-----"
        "-----BEGIN DSA PRIVATE KEY-----"
        "-----BEGIN EC PRIVATE KEY-----"
        "-----BEGIN OPENSSH PRIVATE KEY-----"
        "-----BEGIN PGP PRIVATE KEY-----"
    )
    
    for pattern in "${key_patterns[@]}"; do
        local matches=$(grep -r "$pattern" "$DOTFILES_DIR" \
            --exclude-dir=.git \
            --exclude-dir=.dotfiles.private \
            2>/dev/null)
        
        if [[ -n "$matches" ]]; then
            log "ERROR" "Private key exposed: $pattern"
            return 1
        fi
    done
    
    return 0
}

test_file_permissions() {
    log "TRACE" "Checking file permissions"
    
    local issues=0
    
    # Check for world-writable files
    local world_writable=$(find "$DOTFILES_DIR" -type f -perm -002 2>/dev/null)
    if [[ -n "$world_writable" ]]; then
        log "ERROR" "World-writable files found:"
        echo "$world_writable" | while read -r file; do
            log "ERROR" "  - $file"
        done
        ((issues++))
    fi
    
    # Check for files with excessive permissions
    local excessive_perms=$(find "$DOTFILES_DIR" -type f -perm -077 \
        ! -path "*/\.git/*" \
        ! -name "*.sh" \
        ! -name "*.zsh" \
        2>/dev/null)
    
    if [[ -n "$excessive_perms" ]]; then
        log "WARNING" "Files with excessive permissions (group/other access):"
        echo "$excessive_perms" | head -5 | while read -r file; do
            log "WARNING" "  - $file"
        done
        ((issues++))
    fi
    
    [[ $issues -eq 0 ]] || return 1
    return 0
}

test_no_command_injection() {
    log "TRACE" "Checking for command injection vulnerabilities"
    
    local vulnerable_patterns=(
        'eval\s+"\$'
        'eval\s+`'
        '\$\([^)]*\$[^)]*\)'
        'sh\s+-c\s+"\$'
        'bash\s+-c\s+"\$'
        'zsh\s+-c\s+"\$'
    )
    
    local violations=0
    
    for pattern in "${vulnerable_patterns[@]}"; do
        local matches=$(grep -rE "$pattern" "$DOTFILES_DIR/src" \
            --include="*.sh" \
            --include="*.zsh" \
            --include="*.bash" \
            --exclude-dir=.git \
            2>/dev/null)
        
        if [[ -n "$matches" ]]; then
            log "WARNING" "Potential command injection vulnerability: $pattern"
            ((violations++))
        fi
    done
    
    if [[ $violations -gt 0 ]]; then
        log "WARNING" "Found $violations potential command injection patterns"
    fi
    
    return 0
}

test_secure_temp_files() {
    log "TRACE" "Checking for insecure temporary file usage"
    
    local insecure_patterns=(
        '/tmp/\$'
        'mktemp\s+/tmp/'
        '>\s*/tmp/[^$]'
    )
    
    local violations=0
    
    for pattern in "${insecure_patterns[@]}"; do
        local matches=$(grep -rE "$pattern" "$DOTFILES_DIR/src" \
            --include="*.sh" \
            --include="*.zsh" \
            --include="*.bash" \
            --exclude-dir=.git \
            2>/dev/null | grep -v "mktemp -")
        
        if [[ -n "$matches" ]]; then
            log "WARNING" "Potentially insecure temp file usage: $pattern"
            ((violations++))
        fi
    done
    
    return 0
}

test_no_unsafe_curl_wget() {
    log "TRACE" "Checking for unsafe curl/wget usage"
    
    # Look for curl/wget without proper SSL verification
    local unsafe_patterns=(
        'curl\s+.*--insecure'
        'curl\s+.*-k\s'
        'wget\s+.*--no-check-certificate'
        'curl\s+http://'  # Non-HTTPS URLs
        'wget\s+http://'
    )
    
    local violations=0
    
    for pattern in "${unsafe_patterns[@]}"; do
        local matches=$(grep -rE "$pattern" "$DOTFILES_DIR/src" \
            --include="*.sh" \
            --include="*.zsh" \
            --exclude-dir=.git \
            2>/dev/null)
        
        if [[ -n "$matches" ]]; then
            log "WARNING" "Unsafe download detected: $pattern"
            ((violations++))
        fi
    done
    
    return 0
}

test_git_hooks_security() {
    log "TRACE" "Checking git hooks security"
    
    local hooks_dir="$DOTFILES_DIR/.git/hooks"
    
    if [[ -d "$hooks_dir" ]]; then
        for hook in "$hooks_dir"/*; do
            [[ -f "$hook" ]] || continue
            [[ "$hook" == *.sample ]] && continue
            
            # Check if hook is executable
            if [[ -x "$hook" ]]; then
                log "INFO" "Active git hook found: $(basename "$hook")"
                
                # Check for dangerous patterns in hooks
                if grep -qE "(rm -rf|dd if=|format|mkfs)" "$hook" 2>/dev/null; then
                    log "ERROR" "Dangerous command in git hook: $(basename "$hook")"
                    return 1
                fi
            fi
        done
    fi
    
    return 0
}

test_dependency_vulnerabilities() {
    log "TRACE" "Checking for known vulnerabilities in dependencies"
    
    # Check npm packages if package.json exists
    if [[ -f "$DOTFILES_DIR/package.json" ]]; then
        if command -v npm >/dev/null 2>&1; then
            local audit_output=$(cd "$DOTFILES_DIR" && npm audit --json 2>/dev/null)
            local vulnerabilities=$(echo "$audit_output" | jq '.metadata.vulnerabilities.total' 2>/dev/null)
            
            if [[ -n "$vulnerabilities" ]] && [[ "$vulnerabilities" -gt 0 ]]; then
                log "WARNING" "npm audit found $vulnerabilities vulnerabilities"
                
                local critical=$(echo "$audit_output" | jq '.metadata.vulnerabilities.critical' 2>/dev/null)
                if [[ -n "$critical" ]] && [[ "$critical" -gt 0 ]]; then
                    log "ERROR" "Critical vulnerabilities found: $critical"
                    return 1
                fi
            fi
        fi
    fi
    
    # Check for outdated tools with known vulnerabilities
    local tools_to_check=(
        "openssl:1.0"  # Old OpenSSL versions
        "bash:3."      # Shellshock vulnerable versions
    )
    
    for tool_pattern in "${tools_to_check[@]}"; do
        local tool="${tool_pattern%:*}"
        local bad_version="${tool_pattern#*:}"
        
        if command -v "$tool" >/dev/null 2>&1; then
            local version=$("$tool" --version 2>&1 | head -1)
            if [[ "$version" == *"$bad_version"* ]]; then
                log "WARNING" "Outdated $tool version may have vulnerabilities: $version"
            fi
        fi
    done
    
    return 0
}

test_path_traversal() {
    log "TRACE" "Checking for path traversal vulnerabilities"
    
    local traversal_patterns=(
        '\.\./\.\.'
        'cd\s+\$[^{]'
        'source\s+\$[^{]'
        '\.\s+\$[^{]'
    )
    
    local violations=0
    
    for pattern in "${traversal_patterns[@]}"; do
        local matches=$(grep -rE "$pattern" "$DOTFILES_DIR/src" \
            --include="*.sh" \
            --include="*.zsh" \
            --exclude-dir=.git \
            2>/dev/null)
        
        if [[ -n "$matches" ]]; then
            log "WARNING" "Potential path traversal vulnerability: $pattern"
            ((violations++))
        fi
    done
    
    return 0
}

test_environment_isolation() {
    log "TRACE" "Testing environment isolation"
    
    # Check if scripts properly sanitize environment
    local scripts_without_env_reset=$(grep -L "unset CDPATH\|IFS=" \
        "$DOTFILES_DIR"/src/scripts/*.sh \
        "$DOTFILES_DIR"/src/setup/*.sh \
        2>/dev/null)
    
    if [[ -n "$scripts_without_env_reset" ]]; then
        log "WARNING" "Scripts without environment reset:"
        echo "$scripts_without_env_reset" | while read -r script; do
            log "WARNING" "  - $(basename "$script")"
        done
    fi
    
    return 0
}