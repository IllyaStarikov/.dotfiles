#!/usr/bin/env zsh
# update-dotfiles - Universal system update script
#
# DESCRIPTION:
#   Comprehensive update tool for all package managers, development tools,
#   and plugins across macOS and Linux. Handles failures gracefully.
#
# USAGE:
#   update-dotfiles [OPTIONS]
#
# OPTIONS:
#   --verbose       Show detailed output
#   --dry-run       Show what would be done without executing
#   --skip-system   Skip OS system updates
#   --skip-packages Skip package manager updates
#   --skip-languages Skip language tool updates
#   --skip-tools    Skip development tool updates
#
# UPDATES:
#   - System: macOS updates, Linux package managers
#   - Packages: Homebrew, apt, dnf, pacman
#   - Languages: Node, Python, Ruby, Go, Rust
#   - Tools: Neovim plugins, tmux plugins, shell plugins
#
# Style Guide: https://google.github.io/styleguide/shellguide.html

# Exit on error, but continue on individual command failures
set -euo pipefail

# Configuration
VERBOSE=false
DRY_RUN=false
SKIP_SYSTEM=false
SKIP_PACKAGES=false
SKIP_LANGUAGES=false
SKIP_TOOLS=false

# Track update status
UPDATED_LIST=""
FAILED_LIST=""

# Source common library if available
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
if [[ -f "${SCRIPT_DIR}/common.sh" ]]; then
    source "${SCRIPT_DIR}/common.sh"
else
    # Define minimal functions if common.sh not available
    print_color() {
        local color="$1"
        shift
        case "$color" in
            red) echo -e "\033[31m$*\033[0m" ;;
            green) echo -e "\033[32m$*\033[0m" ;;
            yellow) echo -e "\033[33m$*\033[0m" ;;
            blue) echo -e "\033[34m$*\033[0m" ;;
            *) echo "$*" ;;
        esac
    }
    has_command() { command -v "$1" &> /dev/null; }
    is_macos() { [[ "$(uname)" == "Darwin" ]]; }
    is_linux() { [[ "$(uname)" == "Linux" ]]; }
    detect_os() { if is_macos; then echo "macOS"; elif is_linux; then echo "Linux"; else echo "Unknown"; fi; }
    detect_package_manager() {
        if has_command apt-get; then echo "apt"
        elif has_command dnf; then echo "dnf"
        elif has_command pacman; then echo "pacman"
        else echo "unknown"; fi
    }
fi

# Function to handle errors gracefully
update_with_fallback() {
    local description="$1"
    shift
    echo "$description"
    
    if [[ "${DRY_RUN}" == true ]]; then
        echo "[DRY RUN] Would execute: $*"
        return 0
    fi
    
    if ! "$@"; then
        echo "âš ï¸  $description failed, continuing..."
        FAILED_LIST="${FAILED_LIST}$description\n"
        return 1
    fi
    UPDATED_LIST="${UPDATED_LIST}$description\n"
    return 0
}

# Cleanup function (runs silently)
cleanup() {
    # Create backup directory with timestamp
    local CLEANUP_BACKUP_DIR="$HOME/.dotfiles-cleanup-backups/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$CLEANUP_BACKUP_DIR"
    
    # Backup and clean tmux cache files
    if ls /tmp/.tmux_*_cache 2>/dev/null; then
        mkdir -p "$CLEANUP_BACKUP_DIR/tmux-cache"
        mv /tmp/.tmux_*_cache "$CLEANUP_BACKUP_DIR/tmux-cache/" 2>/dev/null || true
    fi
    
    # Backup and clean Neovim swap files and backups
    if [[ -d ~/.local/state/nvim/swap ]] && ls ~/.local/state/nvim/swap/* 2>/dev/null; then
        mkdir -p "$CLEANUP_BACKUP_DIR/nvim-swap"
        mv ~/.local/state/nvim/swap/* "$CLEANUP_BACKUP_DIR/nvim-swap/" 2>/dev/null || true
    fi
    if [[ -d ~/.local/state/nvim/backup ]] && ls ~/.local/state/nvim/backup/* 2>/dev/null; then
        mkdir -p "$CLEANUP_BACKUP_DIR/nvim-backup"
        mv ~/.local/state/nvim/backup/* "$CLEANUP_BACKUP_DIR/nvim-backup/" 2>/dev/null || true
    fi
    
    # Archive old Neovim log files (keep last 5 active)
    if [[ -d ~/.local/state/nvim ]]; then
        local old_logs=$(find ~/.local/state/nvim -name "*.log" -type f | sort -r | tail -n +6)
        if [[ -n "$old_logs" ]]; then
            mkdir -p "$CLEANUP_BACKUP_DIR/nvim-logs"
            echo "$old_logs" | xargs -I {} mv {} "$CLEANUP_BACKUP_DIR/nvim-logs/" 2>/dev/null || true
        fi
    fi
    
    # Backup zsh completion dump for regeneration
    if ls ~/.zcompdump* 2>/dev/null; then
        mkdir -p "$CLEANUP_BACKUP_DIR/zsh"
        mv ~/.zcompdump* "$CLEANUP_BACKUP_DIR/zsh/" 2>/dev/null || true
    fi
    
    # Clean pip cache
    if command -v pip3 &> /dev/null; then
        pip3 cache purge 2>/dev/null || true
    fi
    
    # Clean npm cache
    if command -v npm &> /dev/null; then
        npm cache clean --force 2>/dev/null || true
    fi
    
    # Clean yarn cache
    if command -v yarn &> /dev/null; then
        yarn cache clean 2>/dev/null || true
    fi
    
    # Clean pnpm store
    if command -v pnpm &> /dev/null; then
        pnpm store prune 2>/dev/null || true
    fi
    
    # Clean macOS specific caches (non-sudo only)
    echo "Cleaning macOS caches..."
    
    # Remove .DS_Store files from dotfiles directory
    find ~/.dotfiles -name ".DS_Store" -depth -exec rm {} \; 2>/dev/null || true
    
    # Clean shell history duplicates
    if [[ -f ~/.zsh_history ]]; then
        # Create backup
        cp ~/.zsh_history ~/.zsh_history.bak 2>/dev/null || true
    fi
}

# Show usage
usage() {
  cat << EOF
Usage: $(basename "$0") [OPTIONS]

Universal system update script. Works on macOS and Linux.
Updates system packages, language package managers, and development tools.

OPTIONS:
  -h, --help         Show this help
  -n, --dry-run      Show what would be updated
  -v, --verbose      Verbose output
  --skip-system      Skip system package updates
  --skip-packages    Skip Homebrew updates
  --skip-languages   Skip language package managers
  --skip-tools       Skip development tools

WHAT GETS UPDATED:
  System:    OS packages, Mac App Store
  Packages:  Homebrew formulae and casks
  Languages: pip, npm, gem, cargo, go
  Tools:     tmux, Neovim, Zsh plugins, dotfiles

EXAMPLES:
  update-dotfiles                    # Update everything
  update-dotfiles --dry-run          # See what would be updated
  update-dotfiles --skip-system      # Skip system updates

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage
      exit 0
      ;;
    -n|--dry-run)
      DRY_RUN=true
      shift
      ;;
    -v|--verbose)
      VERBOSE=true
      set -x
      shift
      ;;
    --skip-system)
      SKIP_SYSTEM=true
      shift
      ;;
    --skip-packages)
      SKIP_PACKAGES=true
      shift
      ;;
    --skip-languages)
      SKIP_LANGUAGES=true
      shift
      ;;
    --skip-tools)
      SKIP_TOOLS=true
      shift
      ;;
    *)
      print_color red "Unknown option: $1"
      usage
      exit 1
      ;;
  esac
done

# Set trap to cleanup on interrupt only (not normal exit)
trap 'cleanup; exit 130' INT TERM

print_color green "ğŸš€ Universal System Update"
echo "OS: $(detect_os)"
if is_linux; then
    echo "Package Manager: $(detect_package_manager)"
fi
echo

# Update system packages function
update_system() {
  print_color blue "ğŸ”„ Updating system packages..."
  
  if is_macos; then
    # macOS System Updates
    echo "Checking for macOS system updates..."
    if softwareupdate -l 2>&1 | grep -q "No new software available"; then
        echo "No macOS system updates available."
    else
        print_color yellow "macOS updates available. Use 'sudo softwareupdate -ia' to install."
    fi
    
    # Mac App Store updates
    if has_command mas; then
        echo "Checking Mac App Store updates..."
        if [[ "${DRY_RUN}" == true ]]; then
            mas outdated
        else
            update_with_fallback "Mac App Store" mas upgrade
        fi
    fi
  elif is_linux; then
    local pm
    pm="$(detect_package_manager)"
    
    case "${pm}" in
      apt)
        echo "Updating APT packages..."
        if [[ "${DRY_RUN}" == true ]]; then
            sudo apt-get update
            apt list --upgradable
        else
            update_with_fallback "APT update" sudo apt-get update
            update_with_fallback "APT upgrade" sudo apt-get upgrade -y
            update_with_fallback "APT autoremove" sudo apt-get autoremove -y
        fi
        ;;
      dnf)
        echo "Updating DNF packages..."
        if [[ "${DRY_RUN}" == true ]]; then
            dnf check-update
        else
            update_with_fallback "DNF upgrade" sudo dnf upgrade -y
            update_with_fallback "DNF autoremove" sudo dnf autoremove -y
        fi
        ;;
      pacman)
        echo "Updating Pacman packages..."
        if [[ "${DRY_RUN}" == true ]]; then
            pacman -Qu
        else
            update_with_fallback "Pacman sync" sudo pacman -Syu --noconfirm
        fi
        ;;
      *)
        print_color yellow "Unknown package manager: ${pm}"
        ;;
    esac
  fi
}

# Update Homebrew function
update_homebrew() {
  if ! has_command brew; then
    return
  fi
  
  print_color blue "ğŸº Updating Homebrew..."
  
  if [[ "${DRY_RUN}" == true ]]; then
    brew update
    brew outdated
    brew outdated --cask
  else
    update_with_fallback "Homebrew update" brew update

# Check for deprecated packages and remove them
echo "Checking for deprecated packages..."
# Use while read instead of mapfile for compatibility
deprecated_packages=()
while IFS= read -r pkg; do
    if [[ -n "$pkg" ]] && [[ "$pkg" =~ ^[a-zA-Z0-9._@+-]+$ ]]; then
        deprecated_packages+=("$pkg")
    fi
done < <(brew outdated --formula 2>&1 | grep -F "has been disabled because it is deprecated" | awk '{print $2}')

if [[ ${#deprecated_packages[@]} -gt 0 ]]; then
    echo "Found deprecated packages: ${deprecated_packages[*]}"
    echo "Removing deprecated packages..."
    # Safely iterate through array with validated package names
    for pkg in "${deprecated_packages[@]}"; do
        # Double-check package name format before using
        if [[ "$pkg" =~ ^[a-zA-Z0-9._@+-]+$ ]]; then
            update_with_fallback "Removing $pkg" brew uninstall --ignore-dependencies -- "$pkg"
        else
            echo "Skipping invalid package name: $pkg" >&2
        fi
    done
fi

    # Upgrade remaining packages
    update_with_fallback "Homebrew formula upgrade" brew upgrade
    update_with_fallback "Homebrew cask upgrade" brew upgrade --cask
    
    # Comprehensive Homebrew cleanup
    echo "Performing Homebrew cleanup..."
    update_with_fallback "Homebrew cleanup" brew cleanup -s
    update_with_fallback "Homebrew doctor" brew doctor || true
    update_with_fallback "Homebrew autoremove" brew autoremove || true
  fi
}

# Update language-specific package managers function
update_languages() {
  print_color blue "ğŸ“¦ Updating language package managers..."
  
  # Python/pip - Skip for Homebrew-managed Python (PEP 668)
  # Use pipx for CLI tools, or virtual environments for project dependencies
  if has_command pip3; then
    echo "Skipping pip upgrades (Homebrew-managed Python, use pipx for CLI tools)"
  fi

  # pipx - Python CLI tool manager
  if has_command pipx; then
    echo "Updating pipx packages..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "pipx upgrade-all" pipx upgrade-all
    fi
  fi
  
  # Node.js/npm
  if has_command npm; then
    echo "Updating npm packages..."
    if [[ "${DRY_RUN}" == true ]]; then
        npm outdated -g
    else
        update_with_fallback "npm global update" npm update -g
        update_with_fallback "npm self-update" npm install -g npm@latest
    fi
  fi
  
  # Ruby/gem
  if has_command gem; then
    echo "Updating Ruby gems..."
    if [[ "${DRY_RUN}" == true ]]; then
        gem outdated
    else
        update_with_fallback "gem system update" gem update --system
        update_with_fallback "gem update" gem update --user-install
        update_with_fallback "gem cleanup" gem cleanup
    fi
  fi
  
  # Rust/cargo
  if has_command rustup; then
    echo "Updating Rust toolchain..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "rustup update" rustup update
    fi
  fi
  
  if has_command cargo; then
    echo "Updating global Cargo packages..."
    # Install cargo-update if not present
    if ! has_command cargo-install-update; then
        echo "Installing cargo-update for better Cargo package management..."
        update_with_fallback "cargo-update installation" cargo install cargo-update
    fi
    
    # Use cargo-update if available
    if has_command cargo-install-update; then
        if [[ "${DRY_RUN}" == false ]]; then
            update_with_fallback "Cargo package update" cargo install-update -a
        fi
    else
        # Fallback to manual method
        cargo install --list | grep -E '^[a-zA-Z0-9_-]+ v[0-9\.]+' | awk '{print $1}' | xargs -n1 cargo install --force 2>/dev/null || true
    fi
  fi
  
  # Go modules
  if has_command go; then
    echo "Updating Go tools..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "gopls update" go install golang.org/x/tools/gopls@latest
        update_with_fallback "gofumpt update" go install mvdan.cc/gofumpt@latest
        update_with_fallback "Go cache clean" go clean -modcache
    fi
  fi
}

# Update development tools function
update_tools() {
  print_color blue "ğŸ› ï¸  Updating development tools..."
  
  # tmux plugins (TPM)
  if [[ -d "${HOME}/.tmux/plugins/tpm" ]]; then
    echo "Updating tmux plugins..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "tmux plugins" "${HOME}/.tmux/plugins/tpm/bin/update_plugins" all
    fi
  fi
  
  # Neovim plugins
  if has_command nvim; then
    echo "Updating Neovim plugins..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "Neovim plugin sync" nvim --headless +"Lazy! sync" +qa
        update_with_fallback "Lazy clean" nvim --headless +"Lazy! clean" +qa
        update_with_fallback "Mason LSP update" nvim --headless +"MasonUpdate" +qa
        # Archive Neovim plugin caches for rebuild
        echo "Archiving Neovim caches..."
        local NVIM_CACHE_BACKUP="$HOME/.dotfiles-cleanup-backups/nvim-cache-$(date +%Y%m%d_%H%M%S)"
        if [[ -d ~/.local/share/nvim/lazy/readme ]]; then
            mkdir -p "$NVIM_CACHE_BACKUP"
            mv ~/.local/share/nvim/lazy/readme "$NVIM_CACHE_BACKUP/lazy-readme" 2>/dev/null || true
        fi
        if [[ -d ~/.cache/nvim/luac ]]; then
            mkdir -p "$NVIM_CACHE_BACKUP"
            mv ~/.cache/nvim/luac "$NVIM_CACHE_BACKUP/luac" 2>/dev/null || true
        fi
    fi
  fi
  
  # Oh My Zsh
  if [[ -d "${HOME}/.oh-my-zsh" ]]; then
    echo "Updating Oh My Zsh..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "Oh My Zsh" sh -c "cd ${HOME}/.oh-my-zsh && git pull --rebase"
    fi
  fi

  # Zinit
  if [[ -d "${HOME}/.local/share/zinit" ]]; then
    echo "Updating Zinit..."
    if [[ "${DRY_RUN}" == false ]]; then
        zsh -ic "zinit self-update" 2>/dev/null || true
        update_with_fallback "Zinit plugins" zsh -ic "zinit update --all" 2>/dev/null
    fi
  fi
  
  # dotfiles repository
  if [[ -d "${HOME}/.dotfiles/.git" ]]; then
    echo "Updating dotfiles..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "dotfiles" sh -c "cd ${HOME}/.dotfiles && git pull --rebase"
    fi
  fi

  # Additional Node.js package managers
  if has_command yarn; then
    echo "Updating global Yarn packages..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "Yarn global upgrade" yarn global upgrade
    fi
  fi
  
  if has_command pnpm; then
    echo "Updating global pnpm packages..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "pnpm global update" pnpm update -g
    fi
  fi
  
  # TeX Live Manager Updates (tlmgr)
  if has_command tlmgr; then
    echo "Checking TeX Live packages (tlmgr)..."
    tlmgr update --list 2>/dev/null | grep -q "update available" && echo "TeX Live updates available. Run 'sudo tlmgr update --all' manually." || echo "No TeX Live updates available."
  fi
  
  # fnm (Fast Node Manager) Updates
  if has_command fnm; then
    echo "Updating Node.js via fnm to latest LTS..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "fnm Node.js update" fnm install --lts
        update_with_fallback "Setting default Node.js version" fnm default lts-latest
    fi
  fi
  
  # pyenv Python Updates
  if has_command pyenv; then
    echo "Checking for new Python versions..."
    if [[ "${DRY_RUN}" == false ]]; then
        # Update pyenv itself first
        if is_macos && has_command brew; then
            update_with_fallback "pyenv update" brew upgrade pyenv
        fi
        # List available Python versions
        echo "Latest stable Python versions available:"
        pyenv install --list | grep -E "^\s*3\.[0-9]+\.[0-9]+$" | tail -5
        
        # List Python versions for manual cleanup
        echo "Installed Python versions:"
        pyenv versions
        echo ""
        echo "To remove unused versions, run: pyenv uninstall <version>"
        
        # Clean pyenv shims
        update_with_fallback "Rehashing pyenv shims" pyenv rehash
    fi
  fi
  
  # Starship Prompt Config Check
  if has_command starship; then
    echo "Checking Starship configuration..."
    if [[ "${DRY_RUN}" == false ]]; then
        update_with_fallback "Starship config check" starship config
    fi
  fi
  
  # FZF Updates (if installed via git)
  if [[ -d "$HOME/.fzf" ]]; then
    echo "Updating fzf..."
    if [[ "${DRY_RUN}" == false ]]; then
        (cd "$HOME/.fzf" && update_with_fallback "fzf update" git pull && update_with_fallback "fzf install" ./install --all)
    fi
  fi
}

# Disk space report
echo ""
echo "ğŸ’¾ Disk Space Report:"
echo "===================="
# Show disk usage for root filesystem (use 'command' to bypass aliases like duf)
command df -h / | head -2

echo ""
echo "ğŸ“¦ Large directories in home:"
du -sh ~/Library/Caches ~/.Trash ~/Downloads ~/.cache ~/.local/share/nvim ~/.npm ~/.yarn ~/.cargo ~/.rustup 2>/dev/null | sort -hr | head -10 || true

echo ""
echo "ğŸ§¹ Cleanup suggestions:"
echo "   - Clear DNS cache: sudo dscacheutil -flushcache"
echo "   - Clear font cache: sudo atsutil databases -remove"
echo "   - Archive trash items: mv ~/.Trash/* ~/Archive/Trash-$(date +%Y%m%d)/"
echo "   - Archive old downloads: find ~/Downloads -type f -mtime +30 -exec mv {} ~/Archive/Downloads-$(date +%Y%m%d)/ \;"
echo "   - Archive macOS caches: mv ~/Library/Caches/* ~/Archive/Caches-$(date +%Y%m%d)/"

# Show summary
show_summary() {
  echo
  echo
  print_color blue "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  if [[ "${DRY_RUN}" == true ]]; then
    print_color yellow "ğŸ” DRY RUN COMPLETE"
    echo "Run without --dry-run to apply updates"
  else
    if [[ -z "${FAILED_LIST}" ]]; then
      print_color green "âœ… UPDATE COMPLETED SUCCESSFULLY"
    else
      print_color yellow "âš ï¸  UPDATE COMPLETED WITH WARNINGS"
    fi

    if [[ -n "${UPDATED_LIST}" ]]; then
      echo
      print_color green "Successfully updated:"
      echo -e "${UPDATED_LIST}" | grep -v '^$' | sed 's/^/  âœ“ /' | sort -u
    fi

    if [[ -n "${FAILED_LIST}" ]]; then
      echo
      print_color yellow "Skipped/Failed (non-critical):"
      echo -e "${FAILED_LIST}" | grep -v '^$' | sed 's/^/  âš  /' | sort -u
    fi
  fi

  print_color blue "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo
}

# Main execution
main() {
  # Run updates based on flags
  if [[ "${SKIP_SYSTEM}" != true ]]; then
    update_system
  fi

  if [[ "${SKIP_PACKAGES}" != true ]]; then
    update_homebrew
  fi

  if [[ "${SKIP_LANGUAGES}" != true ]]; then
    update_languages
  fi

  if [[ "${SKIP_TOOLS}" != true ]]; then
    update_tools
  fi

  # Show summary first, then cleanup
  show_summary
  cleanup
}

main "$@"