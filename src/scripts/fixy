#!/usr/bin/env bash
# fixy - Universal code formatter with priority-based selection
#
# DESCRIPTION:
#   Formats code files using the best available formatter from a prioritized
#   list. Supports 20+ languages with automatic fallback. Can also perform
#   text normalizations like removing trailing whitespace, converting tabs,
#   and keeping marked sections sorted with Google's keep-sorted tool.
#
# USAGE:
#   fixy [OPTIONS] FILE [FILE...]
#   
#   fixy file.py                    # Format Python file
#   fixy --all file.js             # All normalizations + formatting
#   fixy --dry-run file.cpp        # Preview changes without applying
#   fixy --trailing-whitespace *.sh # Only remove trailing whitespace
#
# OPTIONS:
#   -a, --all                Remove trailing spaces, convert tabs, normalize quotes, format, sort, ensure newline
#   -t, --trailing-whitespace Remove trailing whitespace only
#   -T, --tabs-to-spaces     Convert tabs to spaces only
#   -q, --smart-quotes       Normalize smart quotes to ASCII only
#   -f, --formatters         Run language formatters only (default)
#   -s, --sorted            Run keep-sorted on marked sections
#   -N, --newline           Ensure exactly one trailing newline at EOF
#   -p, --parallel [jobs]   Process files in parallel (default: CPU cores)
#   --type TYPE             Override file type detection (see --help for types)
#   -n, --dry-run           Show what would be done without making changes
#   -v, --verbose           Show detailed output
#   -h, --help              Show this help message
#
# CONFIG:
#   Uses ~/.dotfiles/config/fixy.json for formatter priorities
#
# EXAMPLES:
#   fixy src/*.py          # Format all Python files
#   fixy --all README.md   # Clean and format markdown
#   fixy -tv script.sh     # Remove trailing spaces with verbose output
#   fixy -s config.yaml    # Sort marked sections with keep-sorted

# Source common library for cross-platform support
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Strict mode
set -euo pipefail

# Configuration
DO_ALL=false
DO_TRAILING=false
DO_TABS=false
DO_QUOTES=false
DO_FORMATTERS=false
DO_SORTED=false
DO_NEWLINE=false
VERBOSE=false
DRY_RUN=false
PARALLEL=false
FORCE_TYPE=""  # Override file type detection
# Default to number of CPU cores, fallback to 8
if command -v nproc >/dev/null 2>&1; then
  MAX_JOBS=$(nproc)
elif command -v sysctl >/dev/null 2>&1; then
  MAX_JOBS=$(sysctl -n hw.ncpu 2>/dev/null || echo 8)
else
  MAX_JOBS=8
fi
FILES=()
CONFIG_FILE="${HOME}/.dotfiles/config/fixy.json"
KEEP_SORTED_BIN="${HOME}/go/bin/keep-sorted"

# Output helper that suppresses output in parallel mode
# Args: $@ - Arguments to print
print_if_not_parallel() {
  if [[ "${PARALLEL}" != true ]]; then
    "$@"
  fi
}

# Check if a file is binary (not text)
# Args: $1 - File path to check
# Returns: 0 if binary, 1 if text
is_binary_file() {
  local file="${1:?Error: file required}"
  file "$file" | grep -q "binary\|data"
}

# Remove trailing whitespace from file
# Args: $1 - File path to process
# Uses platform-appropriate sed command
remove_trailing_whitespace() {
  local file="${1:?Error: file required}"

  if [[ "${DRY_RUN}" == true ]]; then
    [[ "${PARALLEL}" != true ]] && print_color blue "[DRY RUN] Would remove trailing whitespace from: $file"
  else
    [[ "${PARALLEL}" != true ]] && echo -n "  → Removing trailing whitespace... "
    platform_command \
      "sed -i '' 's/[[:space:]]*$//' '${file}'" \
      "sed -i 's/[[:space:]]*$//' '${file}'"
    [[ "${PARALLEL}" != true ]] && print_color green "✓"
  fi
}

# Convert tabs to spaces using language-appropriate width
# Args: $1 - File path to process
# Python: 4 spaces, Others: 2 spaces (Google style)
convert_tabs_to_spaces() {
  local file="${1:?Error: file required}"
  local tab_width=2

  # Python uses 4 spaces per Google style guide
  if [[ -n "${FORCE_TYPE}" ]]; then
    local ext=$(map_type_to_extension "${FORCE_TYPE}")
    if [[ "$ext" =~ ^(py|pyw|pyi)$ ]]; then
      tab_width=4
    fi
  elif [[ "$file" =~ \.(py|pyw|pyi)$ ]]; then
    tab_width=4
  fi

  if [[ "${DRY_RUN}" == true ]]; then
    [[ "${PARALLEL}" != true ]] && print_color blue "[DRY RUN] Would convert tabs to ${tab_width} spaces in: $file"
  else
    [[ "${PARALLEL}" != true ]] && echo -n "  → Converting tabs to ${tab_width} spaces... "
    expand -t "${tab_width}" "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    [[ "${PARALLEL}" != true ]] && print_color green "✓"
  fi
}

# Ensure file ends with exactly one newline
# Args: $1 - File path to process
# Removes all trailing newlines and adds exactly one
ensure_trailing_newline() {
  local file="${1:?Error: file required}"

  if [[ "${DRY_RUN}" == true ]]; then
    [[ "${PARALLEL}" != true ]] && print_color blue "[DRY RUN] Would ensure single trailing newline in: $file"
  else
    [[ "${PARALLEL}" != true ]] && echo -n "  → Ensuring single trailing newline... "
    # First, check if file is empty
    if [[ ! -s "$file" ]]; then
      [[ "${PARALLEL}" != true ]] && print_color yellow "empty file, skipping"
      return 0
    fi
    
    # Use a temporary file to ensure atomic operation
    local tmpfile="${file}.tmp.$$"
    
    # Remove all trailing newlines, then add exactly one
    # This portable approach:
    # 1. Uses perl to remove ALL trailing blank lines
    # 2. Adds exactly one newline at the end
    if command -v perl >/dev/null 2>&1; then
      # This perl command removes all trailing newlines and whitespace-only lines at the end
      perl -0777 -pe 's/\s*\z/\n/' "$file" > "$tmpfile" && mv "$tmpfile" "$file"
    else
      # Fallback using sed and awk
      # First remove all trailing blank lines, then ensure one newline
      sed -e :a -e '/^\s*$/{ $d; N; ba; }' "$file" | awk 'NR > 1 { print prev } { prev = $0 } END { print prev }' > "$tmpfile" && \
      echo >> "$tmpfile" && mv "$tmpfile" "$file"
    fi
    
    [[ "${PARALLEL}" != true ]] && print_color green "✓"
  fi
}

# Run keep-sorted on file to sort marked sections
# Args: $1 - File path to process
run_keep_sorted() {
  local file="${1:?Error: file required}"
  
  # Check if keep-sorted is available
  if [[ ! -x "${KEEP_SORTED_BIN}" ]]; then
    if [[ "${VERBOSE}" == true ]]; then
      print_color yellow "  → keep-sorted not found, skipping..."
    fi
    return 1
  fi
  
  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "[DRY RUN] Would run keep-sorted on: $file"
    # Show what would be sorted
    if [[ "${VERBOSE}" == true ]]; then
      "${KEEP_SORTED_BIN}" --mode=lint "$file" 2>/dev/null || true
    fi
  else
    echo -n "  → Running keep-sorted... "
    # Create a backup in case something goes wrong
    local temp_file="${file}.keep-sorted-tmp"
    cp "$file" "$temp_file"
    
    # Run keep-sorted
    if "${KEEP_SORTED_BIN}" "$file" 2>/dev/null; then
      rm -f "$temp_file"
      print_color green "✓"
    else
      # Restore backup if keep-sorted failed
      mv "$temp_file" "$file"
      print_color yellow "skipped (no sortable sections)"
      return 1
    fi
  fi
}

# Normalize smart quotes to regular quotes
normalize_quotes() {
  local file="${1:?Error: file required}"

  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "[DRY RUN] Would normalize smart quotes in: $file"
  else
    echo -n "  → Normalizing smart quotes... "
    # Use perl for reliable cross-platform Unicode handling
    perl -i -pe 's/\x{2018}/\x27/g; s/\x{2019}/\x27/g; s/\x{201C}/"/g; s/\x{201D}/"/g' "$file" 2>/dev/null || true
    print_color green "✓"
  fi
}

# Load configuration from JSON file
load_config() {
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    if [[ "${VERBOSE}" == true ]]; then
      print_color yellow "Config file not found: ${CONFIG_FILE}"
      print_color yellow "Using built-in defaults"
    fi
    return 1
  fi
  return 0
}

# Get formatters for an extension from config
get_formatters_from_config() {
  local ext="${1}"
  if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
    python3 -c "
import json
import sys
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        ext_config = config.get('extensions', {}).get('${ext}', {})
        if ext_config:
            formatters = ext_config.get('formatters', [])
            print(' '.join(formatters))
except:
    pass
" 2>/dev/null || echo ""
  else
    echo ""
  fi
}

# Get formatter command from config
get_formatter_command() {
  local formatter="${1}"
  local file="${2}"
  if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
    python3 -c "
import json
import sys
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        fmt = config.get('formatters', {}).get('${formatter}', {})
        if fmt:
            cmd = fmt.get('command', '')
            args = fmt.get('format_args', '')
            if cmd and args:
                args = args.replace('{file}', '${file}')
                if cmd == 'internal':
                    print(args)
                else:
                    print(f'{cmd} {args}')
except:
    pass
" 2>/dev/null || echo ""
  else
    echo ""
  fi
}

# Get additional formatters for an extension
get_additional_formatters() {
  local ext="${1}"
  if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
    python3 -c "
import json
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        ext_config = config.get('extensions', {}).get('${ext}', {})
        if ext_config:
            additional = ext_config.get('additional', [])
            print(' '.join(additional))
except:
    pass
" 2>/dev/null || echo ""
  else
    echo ""
  fi
}

# Get language name for extension
get_language_name() {
  local ext="${1}"
  if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
    python3 -c "
import json
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        ext_config = config.get('extensions', {}).get('${ext}', {})
        print(ext_config.get('language', ''))
except:
    pass
" 2>/dev/null || echo ""
  else
    echo ""
  fi
}

# Get list of allowed extensions from config or fallback
get_allowed_extensions() {
  if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
    python3 -c "
import json
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        extensions = list(config.get('extensions', {}).keys())
        print(' '.join(sorted(extensions)))
except:
    pass
" 2>/dev/null || echo "py pyw pyi c h cpp cc cxx hpp hxx sh bash zsh lua js jsx ts tsx json yaml yml html css scss md txt text log csv"
  else
    echo "py pyw pyi c h cpp cc cxx hpp hxx sh bash zsh lua js jsx ts tsx json yaml yml html css scss md txt text log csv"
  fi
}

# Map a type name to an extension
# Args: $1 - Type name (e.g., "python", "shell", "cpp")
# Returns: The primary extension for that type
map_type_to_extension() {
  local type_name="$(echo "$1" | tr '[:upper:]' '[:lower:]')"  # Convert to lowercase
  
  case "$type_name" in
    python|py) echo "py" ;;
    c) echo "c" ;;
    cpp|c++|cplusplus) echo "cpp" ;;
    shell|sh|bash|zsh) echo "sh" ;;
    lua) echo "lua" ;;
    javascript|js) echo "js" ;;
    typescript|ts) echo "ts" ;;
    json) echo "json" ;;
    yaml|yml) echo "yaml" ;;
    html) echo "html" ;;
    css) echo "css" ;;
    scss) echo "scss" ;;
    sass) echo "sass" ;;
    less) echo "less" ;;
    markdown|md) echo "md" ;;
    rust|rs) echo "rs" ;;
    go|golang) echo "go" ;;
    text|txt) echo "txt" ;;
    xml) echo "xml" ;;
    svg) echo "svg" ;;
    graphql|gql) echo "graphql" ;;
    vue) echo "vue" ;;
    svelte) echo "svelte" ;;
    swift) echo "swift" ;;
    sql) echo "sql" ;;
    latex|tex) echo "tex" ;;
    bibtex|bib) echo "bib" ;;
    cmake) echo "cmake" ;;
    ruby|rb) echo "rb" ;;
    toml) echo "toml" ;;
    perl|pl) echo "pl" ;;
    assembly|asm) echo "asm" ;;
    makefile|mk|make) echo "makefile" ;;
    *)
      # Try to use the type name directly as an extension
      echo "$type_name"
      ;;
  esac
}

# Get list of supported languages (types) from config
# Returns human-readable list of supported types with descriptions
get_supported_types() {
  if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
    python3 -c "
import json
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        extensions = config.get('extensions', {})
        
        # Create mapping of language to extensions
        lang_to_exts = {}
        for ext, info in extensions.items():
            lang = info.get('language', ext.upper())
            if lang not in lang_to_exts:
                lang_to_exts[lang] = []
            lang_to_exts[lang].append(ext)
        
        # Sort and format output
        for lang in sorted(lang_to_exts.keys()):
            exts = ', '.join(sorted(lang_to_exts[lang])[:5])  # Show first 5 extensions
            if len(lang_to_exts[lang]) > 5:
                exts += ', ...'
            print(f'  {lang.lower():<15} # {lang} files ({exts})')
except Exception as e:
    print(f'Error loading config: {e}')
"
  else
    # Fallback type list
    cat << 'EOF'
  python          # Python files (py, pyw, pyi)
  c               # C files (c, h)
  cpp             # C++ files (cpp, cc, cxx, hpp, hxx)
  shell,sh        # Shell scripts (sh, bash, zsh)
  lua             # Lua files (lua)
  javascript,js   # JavaScript files (js, jsx)
  typescript,ts   # TypeScript files (ts, tsx)
  json            # JSON files (json)
  yaml            # YAML files (yaml, yml)
  html            # HTML files (html)
  css             # CSS files (css, scss, sass, less)
  markdown,md     # Markdown files (md, mdx)
  rust,rs         # Rust files (rs)
  go              # Go files (go)
  text,txt        # Text files (txt, text, log, csv, tsv)
  xml             # XML files (xml, svg)
  sql             # SQL files (sql)
  ruby,rb         # Ruby files (rb, rake, gemspec)
  toml            # TOML files (toml)
  perl,pl         # Perl files (pl, pm)
  assembly,asm    # Assembly files (asm, s, S)
  makefile,mk     # Makefiles (mk, makefile, Makefile)
EOF
  fi
}

# Check if extension is allowed
is_extension_allowed() {
  local ext="${1}"
  local allowed
  allowed=$(get_allowed_extensions)
  
  for allowed_ext in $allowed; do
    if [[ "$ext" == "$allowed_ext" ]]; then
      return 0
    fi
  done
  return 1
}

# Run formatter with priority queue
run_formatter_with_priority() {
  local file="${1:?Error: file required}"
  local ext
  
  # Use forced type if specified, otherwise extract from filename
  if [[ -n "${FORCE_TYPE}" ]]; then
    ext=$(map_type_to_extension "${FORCE_TYPE}")
  else
    ext="${file##*.}"
  fi
  
  local formatted=false
  
  # Get formatters for this extension
  local formatters
  formatters=$(get_formatters_from_config "$ext")
  
  if [[ -z "$formatters" ]]; then
    return 1
  fi
  
  # Try formatters in priority order
  for formatter in $formatters; do
    # Check if formatter is available
    local check_cmd
    if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
      check_cmd=$(python3 -c "
import json
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        fmt = config.get('formatters', {}).get('${formatter}', {})
        cmd = fmt.get('command', '')
        if cmd == 'internal':
            print('internal')
        elif cmd:
            print(cmd)
except:
    pass
" 2>/dev/null)
    fi
    
    if [[ "$check_cmd" == "internal" ]]; then
      # Internal formatter (text files)
      if [[ "${DRY_RUN}" == true ]]; then
        print_color blue "[DRY RUN] Would run internal text formatter on: $file"
      else
        echo -n "  → Running text formatter... "
        # Remove trailing whitespace
        platform_command \
          "sed -i '' 's/[[:space:]]*$//' '${file}'" \
          "sed -i 's/[[:space:]]*$//' '${file}'"
        # Normalize smart quotes
        perl -i -pe 's/\x{2018}/\x27/g; s/\x{2019}/\x27/g; s/\x{201C}/"/g; s/\x{201D}/"/g' "$file" 2>/dev/null || true
        print_color green "✓"
      fi
      formatted=true
      break
    elif [[ -n "$check_cmd" ]] && has_command "$check_cmd"; then
      # External formatter
      local format_cmd
      format_cmd=$(get_formatter_command "$formatter" "$file")
      
      if [[ -n "$format_cmd" ]]; then
        if [[ "${DRY_RUN}" == true ]]; then
          print_color blue "[DRY RUN] Would run $formatter on: $file"
          if [[ "${VERBOSE}" == true ]]; then
            echo "    Command: $format_cmd"
          fi
        else
          echo -n "  → Running $formatter... "
          if [[ "$formatter" == "ruff" ]]; then
            # Special handling for ruff (run check first)
            ruff check --fix --line-length 100 "$file" 2>/dev/null || true
          fi
          eval "$format_cmd" 2>/dev/null || true
          print_color green "✓"
        fi
        formatted=true
        break
      fi
    elif [[ "${VERBOSE}" == true ]]; then
      print_color yellow "    $formatter not available"
    fi
  done
  
  # Run additional formatters if configured
  local additional
  additional=$(get_additional_formatters "$ext")
  if [[ -n "$additional" ]] && [[ "$formatted" == true ]]; then
    for formatter in $additional; do
      local check_cmd
      if [[ -f "${CONFIG_FILE}" ]] && has_command python3; then
        check_cmd=$(python3 -c "
import json
try:
    with open('${CONFIG_FILE}') as f:
        config = json.load(f)
        fmt = config.get('formatters', {}).get('${formatter}', {})
        print(fmt.get('command', ''))
except:
    pass
" 2>/dev/null)
      fi
      
      if [[ -n "$check_cmd" ]] && has_command "$check_cmd"; then
        local format_cmd
        format_cmd=$(get_formatter_command "$formatter" "$file")
        if [[ -n "$format_cmd" ]]; then
          if [[ "${DRY_RUN}" == false ]]; then
            echo -n "  → Running $formatter (additional)... "
            eval "$format_cmd" 2>/dev/null || true
            print_color green "✓"
          fi
        fi
      fi
    done
  fi
  
  if [[ "$formatted" == true ]]; then
    return 0
  fi
  return 1
}

# Fallback formatters for when config is not available
format_fallback() {
  local file="${1:?Error: file required}"
  local ext
  
  # Use forced type if specified, otherwise extract from filename
  if [[ -n "${FORCE_TYPE}" ]]; then
    ext=$(map_type_to_extension "${FORCE_TYPE}")
  else
    ext="${file##*.}"
  fi
  
  case "${ext}" in
    py|pyw|pyi)
      # Python fallback
      if has_command ruff; then
        if [[ "${DRY_RUN}" == true ]]; then
          print_color blue "[DRY RUN] Would run ruff (fallback) on: $file"
        else
          echo -n "  → Running ruff (fallback)... "
          ruff check --fix --line-length 100 "$file" 2>/dev/null || true
          ruff format --line-length 100 "$file" 2>/dev/null || true
          print_color green "✓"
        fi
        return 0
      elif has_command black; then
        if [[ "${DRY_RUN}" == true ]]; then
          print_color blue "[DRY RUN] Would run black (fallback) on: $file"
        else
          echo -n "  → Running black (fallback)... "
          black -q --line-length 100 --skip-string-normalization "$file"
          print_color green "✓"
        fi
        return 0
      fi
      ;;
    c|h|cpp|cc|cxx|hpp|hxx)
      # C/C++ fallback
      if has_command clang-format; then
        if [[ "${DRY_RUN}" == true ]]; then
          print_color blue "[DRY RUN] Would run clang-format (fallback) on: $file"
        else
          echo -n "  → Running clang-format (fallback)... "
          clang-format -i -style='{BasedOnStyle: Google, IndentWidth: 2, ColumnLimit: 80}' "$file"
          print_color green "✓"
        fi
        return 0
      fi
      ;;
    sh|bash|zsh)
      # Shell fallback
      if has_command shfmt; then
        if [[ "${DRY_RUN}" == true ]]; then
          print_color blue "[DRY RUN] Would run shfmt (fallback) on: $file"
        else
          echo -n "  → Running shfmt (fallback)... "
          shfmt -i 2 -bn -ci -w "$file"
          print_color green "✓"
        fi
        return 0
      fi
      ;;
    lua)
      # Lua fallback
      if has_command stylua; then
        if [[ "${DRY_RUN}" == true ]]; then
          print_color blue "[DRY RUN] Would run stylua (fallback) on: $file"
        else
          echo -n "  → Running stylua (fallback)... "
          stylua --config-path ~/.dotfiles/src/stylua.toml "$file"
          print_color green "✓"
        fi
        return 0
      fi
      ;;
    js|jsx|ts|tsx|json|yaml|yml|html|css|scss|md)
      # Web fallback
      local cmd=""
      if has_command prettierd; then
        cmd="prettierd"
      elif has_command prettier; then
        cmd="prettier"
      fi
      
      if [[ -n "$cmd" ]]; then
        if [[ "${DRY_RUN}" == true ]]; then
          print_color blue "[DRY RUN] Would run $cmd (fallback) on: $file"
        else
          echo -n "  → Running $cmd (fallback)... "
          $cmd --write --tab-width 2 --print-width 80 --single-quote --trailing-comma none --arrow-parens avoid "$file" 2>/dev/null
          print_color green "✓"
        fi
        return 0
      fi
      ;;
    txt|text|log|csv)
      # Text fallback
      if [[ "${DRY_RUN}" == true ]]; then
        print_color blue "[DRY RUN] Would format text file (fallback): $file"
      else
        echo -n "  → Formatting text file (fallback)... "
        platform_command \
          "sed -i '' 's/[[:space:]]*$//' '${file}'" \
          "sed -i 's/[[:space:]]*$//' '${file}'"
        perl -i -pe 's/\x{2018}/\x27/g; s/\x{2019}/\x27/g; s/\x{201C}/"/g; s/\x{201D}/"/g' "$file" 2>/dev/null || true
        print_color green "✓"
      fi
      return 0
      ;;
  esac
  
  return 1
}

# Apply formatters based on file type
apply_formatters() {
  local file="${1:?Error: file required}"
  local ext
  
  # Use forced type if specified, otherwise extract from filename
  if [[ -n "${FORCE_TYPE}" ]]; then
    ext=$(map_type_to_extension "${FORCE_TYPE}")
  else
    ext="${file##*.}"
  fi
  
  local basename="$(basename "$file")"

  # Extension should already be validated by process_file
  # This is just a safety check
  if ! is_extension_allowed "$ext"; then
    return
  fi
  
  # Get language name from config
  local language
  language=$(get_language_name "$ext")
  
  if [[ -n "$language" ]]; then
    print_color blue "  ℹ Detected: ${language} (.${ext})"
  else
    print_color blue "  ℹ Detected: .${ext}"
  fi
  
  # Try config-based formatting first
  if ! run_formatter_with_priority "$file"; then
    # Fallback to built-in formatters if config fails
    if [[ "${VERBOSE}" == true ]]; then
      print_color yellow "  ⚠ Config-based formatting unavailable, trying fallback"
    fi
    if ! format_fallback "$file"; then
      print_color yellow "  ⚠ No formatter available for .${ext}"
      local formatters
      formatters=$(get_formatters_from_config "$ext")
      if [[ -n "$formatters" ]]; then
        echo "    Install one of: $formatters"
      fi
    fi
  fi
}

# Process a single file
process_file() {
  local file="${1:?Error: file required}"
  local ext
  
  # Use forced type if specified, otherwise extract from filename
  if [[ -n "${FORCE_TYPE}" ]]; then
    # Map the type name to an extension
    ext=$(map_type_to_extension "${FORCE_TYPE}")
  else
    ext="${file##*.}"
  fi
  
  local basename="$(basename "$file")"

  if [[ ! -f "$file" ]]; then
    print_color red "File not found: $file"
    return 1
  fi

  # Skip binary files early
  if is_binary_file "$file"; then
    if [[ "${VERBOSE}" == true ]] && [[ "${PARALLEL}" != true ]]; then
      print_color yellow "Skipping binary file: $file"
    fi
    return 2  # Return 2 for skipped files
  fi

  # Check if extension is allowed BEFORE any processing
  if ! is_extension_allowed "$ext"; then
    # Check shebang for shell scripts without extension
    if [[ -x "$file" ]] && [[ -z "$ext" || "$ext" == "$basename" ]] && head -n1 "$file" 2>/dev/null | grep -q "^#!/.*sh"; then
      # Shell script with shebang - allow processing
      ext="sh"
    else
      if [[ "${VERBOSE}" == true ]] && [[ "${PARALLEL}" != true ]]; then
        print_color yellow "Skipping unsupported file type: $file (.${ext})"
      fi
      return 2  # Return 2 for skipped files
    fi
  fi

  # Only show individual file headers in non-parallel mode
  if [[ "${PARALLEL}" != true ]]; then
    echo
    print_color blue "━━━ Processing: $file ━━━"
  fi

  # Apply operations only to allowed files
  if [[ "${DO_TRAILING}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    remove_trailing_whitespace "$file"
  fi

  if [[ "${DO_TABS}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    convert_tabs_to_spaces "$file"
  fi

  if [[ "${DO_QUOTES}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    normalize_quotes "$file"
  fi

  if [[ "${DO_FORMATTERS}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    apply_formatters "$file"
  fi
  
  if [[ "${DO_SORTED}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    run_keep_sorted "$file"
  fi

  if [[ "${DO_NEWLINE}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    ensure_trailing_newline "$file"
  fi
  
  return 0  # Return 0 for successfully processed files
}

# Show usage
usage() {
  cat << EOF
Usage: $(basename "$0") [OPTIONS] [FILES...]

Universal code formatter with configuration-based formatter selection.
Reads formatter configuration from: ${CONFIG_FILE}

OPTIONS:
  -h, --help          Show this help
  -a, --all           Apply all operations (default)
  -t, --trailing      Remove trailing whitespace
  -T, --tabs          Convert tabs to spaces
  -q, --quotes        Normalize smart quotes
  -f, --formatters    Apply language formatters
  -s, --sorted        Apply keep-sorted to marked sections
  -N, --newline       Ensure exactly one trailing newline at EOF
  -p, --parallel [N]  Process files in parallel (default: ${MAX_JOBS} jobs)
  --type TYPE         Override file type detection (see supported types below)
  -n, --dry-run       Show what would be done
  -v, --verbose       Verbose output
  -c, --config FILE   Use alternate config file

CONFIGURATION:
  The formatter uses a priority queue system where:
  - Each file extension maps to a list of formatters in priority order
  - The first available formatter in the list is used
  - Additional formatters (like isort for Python) run after the main formatter
  - Config file: ~/.dotfiles/config/fixy.json

SUPPORTED EXTENSIONS:
$(get_allowed_extensions | tr ' ' '\n' | sort | column -c 80)

SUPPORTED TYPES (for --type option):
$(get_supported_types)

EXAMPLES:
  fixy                           # Format all tracked files
  fixy main.cpp                  # Format single file
  fixy -t *.py                   # Remove trailing whitespace
  fixy --type python script      # Format script as Python
  fixy --type sh Dockerfile      # Format Dockerfile as shell script
  fixy -n --all                  # Dry run
  fixy -v *.py                   # Verbose output

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage
      exit 0
      ;;
    -a|--all)
      DO_ALL=true
      shift
      ;;
    -t|--trailing)
      DO_TRAILING=true
      shift
      ;;
    -T|--tabs)
      DO_TABS=true
      shift
      ;;
    -q|--quotes)
      DO_QUOTES=true
      shift
      ;;
    -f|--formatters)
      DO_FORMATTERS=true
      shift
      ;;
    -s|--sorted|--keep-sorted)
      DO_SORTED=true
      shift
      ;;
    -N|--newline)
      DO_NEWLINE=true
      shift
      ;;
    -p|--parallel)
      PARALLEL=true
      # Check if next argument is a number
      if [[ ${2:-} =~ ^[0-9]+$ ]]; then
        MAX_JOBS=$2
        shift 2
      else
        shift
      fi
      ;;
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    -n|--dry-run)
      DRY_RUN=true
      shift
      ;;
    -c|--config)
      CONFIG_FILE="$2"
      shift 2
      ;;
    --type)
      if [[ -z "${2:-}" ]]; then
        print_color red "Error: --type requires an argument"
        usage
        exit 1
      fi
      FORCE_TYPE="$2"
      shift 2
      ;;
    -*)
      print_color red "Unknown option: $1"
      usage
      exit 1
      ;;
    *)
      FILES+=("$1")
      shift
      ;;
  esac
done

# Default to all operations if none specified
if [[ "${DO_TRAILING}" == false ]] && [[ "${DO_TABS}" == false ]] && \
   [[ "${DO_QUOTES}" == false ]] && [[ "${DO_FORMATTERS}" == false ]] && \
   [[ "${DO_SORTED}" == false ]] && [[ "${DO_NEWLINE}" == false ]]; then
  DO_ALL=true
fi

# Load configuration
load_config

# If no files specified, use git tracked files
if [[ ${#FILES[@]} -eq 0 ]]; then
  if git rev-parse --git-dir > /dev/null 2>&1; then
    print_color blue "No files specified, formatting all tracked files..."
    mapfile -t FILES < <(git ls-files)
  else
    print_color red "No files specified and not in a git repository"
    exit 1
  fi
fi

# Process a single file in background
# Args: $1 - File path
# Returns: Exit code via temp file
process_file_parallel() {
  local file="$1"
  local tmpdir="$2"
  local index="$3"
  
  # Create a unique result file for this job
  local result_file="${tmpdir}/result_${index}"
  
  # Process the file and capture the result
  if process_file "$file"; then
    echo "0" > "$result_file"
  else
    local result=$?
    echo "$result" > "$result_file"
  fi
}

# Process files in parallel
# Args: Array of files to process
# Returns: Summary of processed/skipped/failed
process_files_parallel() {
  local tmpdir
  tmpdir=$(mktemp -d) || {
    print_color red "Failed to create temp directory for parallel processing"
    return 1
  }
  
  # Ensure cleanup on exit
  trap "rm -rf '$tmpdir'" EXIT
  
  local job_count=0
  local file_index=0
  local total_files=$#
  
  # Arrays to track results
  local processed=0
  local skipped=0
  local failed=0
  
  print_color blue "Processing ${total_files} files with up to ${MAX_JOBS} parallel jobs..."
  echo
  
  # Process all files
  for file in "$@"; do
    # Wait if we've reached max parallel jobs
    while (( $(jobs -r | wc -l) >= MAX_JOBS )); do
      sleep 0.1
    done
    
    # Launch background job
    (
      process_file_parallel "$file" "$tmpdir" "$file_index"
    ) &
    
    ((file_index++))
    
    # Show progress every 10 files in non-verbose mode
    if [[ "${VERBOSE}" != true ]] && (( file_index % 10 == 0 )); then
      echo -ne "\r  Progress: ${file_index}/${total_files} files..."
    fi
  done
  
  # Wait for all background jobs to complete
  wait
  
  # Clear progress line
  if [[ "${VERBOSE}" != true ]]; then
    echo -ne "\r                                        \r"
  fi
  
  # Collect results
  for ((i=0; i<file_index; i++)); do
    local result_file="${tmpdir}/result_${i}"
    if [[ -f "$result_file" ]]; then
      local result=$(cat "$result_file")
      case "$result" in
        0) ((processed++)) ;;
        2) ((skipped++)) ;;
        *) ((failed++)) ;;
      esac
    else
      ((failed++))
    fi
  done
  
  # Clean up temp directory
  rm -rf "$tmpdir"
  
  # Display summary
  echo
  print_color blue "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "📋 DRY RUN COMPLETE (PARALLEL)"
  else
    print_color green "✅ FORMATTING COMPLETE (PARALLEL)"
  fi
  echo "   Processed: ${processed} files"
  if [[ $skipped -gt 0 ]]; then
    echo "   Skipped: ${skipped} files"
  fi
  if [[ $failed -gt 0 ]]; then
    print_color red "   Failed: ${failed} files"
  fi
}

# Main execution
main() {
  # Collect all files to process
  local all_files=()
  
  for file in "${FILES[@]}"; do
    if [[ -e "$file" ]]; then
      if [[ -d "$file" ]]; then
        # Add all files from directory
        while IFS= read -r -d '' f; do
          all_files+=("$f")
        done < <(find "$file" -type f -print0)
      else
        # Add single file
        all_files+=("$file")
      fi
    else
      # Handle glob patterns
      local found=false
      for f in $file; do
        if [[ -f "$f" ]]; then
          found=true
          all_files+=("$f")
        fi
      done
      
      if [[ "${found}" == false ]]; then
        print_color yellow "No files match: $file"
      fi
    fi
  done
  
  # Check if we have any files to process
  if [[ ${#all_files[@]} -eq 0 ]]; then
    print_color yellow "No files to process"
    return 0
  fi
  
  # Process files either in parallel or sequentially
  if [[ "${PARALLEL}" == true ]]; then
    # Process in parallel
    process_files_parallel "${all_files[@]}"
  else
    # Process sequentially (original behavior)
    local processed=0
    local skipped=0
    local failed=0
    
    for file in "${all_files[@]}"; do
      local result
      process_file "$file" || result=$?
      if [[ ${result:-0} -eq 0 ]]; then
        ((processed++))
      elif [[ ${result:-0} -eq 2 ]]; then
        ((skipped++))
      else
        ((failed++))
      fi
    done
    
    # Summary for sequential processing
    echo
    print_color blue "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    if [[ "${DRY_RUN}" == true ]]; then
      print_color blue "📋 DRY RUN COMPLETE"
      echo "   Would process: ${processed} files"
    else
      print_color green "✅ FORMATTING COMPLETE"
      echo "   Processed: ${processed} files"
    fi
    
    if [[ ${skipped} -gt 0 ]]; then
      echo "   Skipped: ${skipped} files"
    fi
    
    if [[ ${failed} -gt 0 ]]; then
      print_color red "   Failed: ${failed} files"
      exit 1
    fi
  fi
}

main "$@"