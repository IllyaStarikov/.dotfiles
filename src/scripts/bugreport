#!/usr/bin/env zsh
# bugreport - Comprehensive bug report generator for dotfiles diagnostics
#
# DESCRIPTION:
#   Collects system information, configuration, and diagnostic data for
#   troubleshooting dotfiles issues. Sanitizes sensitive information by default.
#   Creates a compressed archive with all relevant system and configuration data.
#
# USAGE:
#   bugreport [OPTIONS]
#
# OPTIONS:
#   --test[=SIZE]   Run tests and include results (SIZE: small, medium, large)
#   --no-logs       Exclude log files from report
#   --no-sanitize   Don't sanitize sensitive information (use with caution)
#   --debug         Enable debug output
#   -h, --help      Show detailed help
#
# OUTPUT:
#   Creates compressed archive: dotfiles_bugreport_TIMESTAMP.tar.gz
#
# Style Guide: https://google.github.io/styleguide/shellguide.html

set -euo pipefail

readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
readonly DOTFILES_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
readonly TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
readonly REPORT_DIR="${DOTFILES_DIR}/bugreport_${TIMESTAMP}"
readonly ARCHIVE_NAME="dotfiles_bugreport_${TIMESTAMP}.tar.gz"

# Configuration
DEBUG_MODE=0
TEST_MODE=0
TEST_SIZE="large"
INCLUDE_LOGS=1
SANITIZE_OUTPUT=1

# Colors
if [[ -t 1 ]]; then
    readonly RED=$'\033[0;31m'
    readonly GREEN=$'\033[0;32m'
    readonly YELLOW=$'\033[0;33m'
    readonly BLUE=$'\033[0;34m'
    readonly CYAN=$'\033[0;36m'
    readonly BOLD=$'\033[1m'
    readonly NC=$'\033[0m'
else
    readonly RED=""
    readonly GREEN=""
    readonly YELLOW=""
    readonly BLUE=""
    readonly CYAN=""
    readonly BOLD=""
    readonly NC=""
fi

#######################################
# Display usage information
#######################################
usage() {
    cat << EOF
${BOLD}Dotfiles Bug Report Generator${NC}

${BOLD}USAGE:${NC}
    $SCRIPT_NAME [OPTIONS]

${BOLD}OPTIONS:${NC}
    --test[=SIZE]   Run tests and include results (SIZE: small, medium, large)
    --no-logs       Exclude log files from report
    --no-sanitize   Don't sanitize sensitive information
    --debug         Enable debug output
    -h, --help      Show this help message

${BOLD}DESCRIPTION:${NC}
    Generates a comprehensive bug report containing:
    - System information and hardware details
    - Installed software versions
    - Dotfiles configuration
    - Environment variables (sanitized)
    - Shell configuration
    - Editor configuration (Neovim, Vim)
    - Terminal configuration
    - Package manager information
    - Network configuration (sanitized)
    - Process information
    - Disk usage statistics
    - Recent system logs (if permitted)
    - Test results (if --test is specified)

    The report is sanitized by default to remove sensitive information
    such as API keys, tokens, passwords, and personal data.

${BOLD}OUTPUT:${NC}
    Creates a compressed archive: ${ARCHIVE_NAME}

${BOLD}EXAMPLES:${NC}
    $SCRIPT_NAME                  # Generate standard bug report
    $SCRIPT_NAME --test           # Include all test results
    $SCRIPT_NAME --test=small     # Include only quick tests
    $SCRIPT_NAME --debug          # Show detailed progress

EOF
}

#######################################
# Log message with level and color
#######################################
log() {
    local level="$1"
    shift
    local message="$*"
    
    case "$level" in
        DEBUG)
            [[ $DEBUG_MODE -eq 1 ]] && echo "${CYAN}[DEBUG]${NC} $message" >&2
            ;;
        INFO)
            echo "${BLUE}[INFO]${NC} $message"
            ;;
        WARN)
            echo "${YELLOW}[WARN]${NC} $message" >&2
            ;;
        ERROR)
            echo "${RED}[ERROR]${NC} $message" >&2
            ;;
        SUCCESS)
            echo "${GREEN}[✓]${NC} $message"
            ;;
        PROGRESS)
            echo "${BOLD}▶${NC} $message"
            ;;
    esac
}

#######################################
# Parse command line arguments
#######################################
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --test)
                TEST_MODE=1
                TEST_SIZE="large"
                shift
                ;;
            --test=*)
                TEST_MODE=1
                TEST_SIZE="${1#*=}"
                shift
                ;;
            --no-logs)
                INCLUDE_LOGS=0
                shift
                ;;
            --no-sanitize)
                SANITIZE_OUTPUT=0
                shift
                ;;
            --debug)
                DEBUG_MODE=1
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                log ERROR "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

#######################################
# Create report directory structure
#######################################
setup_report_dir() {
    log PROGRESS "Creating report directory"
    
    mkdir -p "$REPORT_DIR"/{system,config,logs,tests,debug}
    
    # Create metadata file
    cat > "$REPORT_DIR/metadata.json" << EOF
{
    "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
    "version": "1.0.0",
    "dotfiles_dir": "$DOTFILES_DIR",
    "hostname": "$(hostname -s)",
    "user": "$(whoami)",
    "report_id": "${TIMESTAMP}",
    "options": {
        "debug": $DEBUG_MODE,
        "test": $TEST_MODE,
        "test_size": "$TEST_SIZE",
        "include_logs": $INCLUDE_LOGS,
        "sanitized": $SANITIZE_OUTPUT
    }
}
EOF
    
    log SUCCESS "Report directory created: $REPORT_DIR"
}

#######################################
# Sanitize sensitive information
#######################################
sanitize() {
    local input="$1"
    
    if [[ $SANITIZE_OUTPUT -eq 0 ]]; then
        echo "$input"
        return
    fi
    
    echo "$input" | sed -E \
        -e 's/[A-Za-z0-9+\/]{40,}/<REDACTED_TOKEN>/g' \
        -e 's/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/<IP_ADDRESS>/g' \
        -e 's/([A-Za-z0-9._%+-]+)@([A-Za-z0-9.-]+\.[A-Za-z]{2,})/<EMAIL>/g' \
        -e 's/(api[_-]?key|token|secret|password|passwd|pwd)[[:space:]]*[=:][[:space:]]*[^[:space:]]+/<REDACTED>/gi' \
        -e 's/\/Users\/[^\/]+/\/Users\/<USER>/g' \
        -e 's/\/home\/[^\/]+/\/home\/<USER>/g'
}

#######################################
# Collect system information
#######################################
collect_system_info() {
    log PROGRESS "Collecting system information"
    
    local sys_file="$REPORT_DIR/system/system_info.txt"
    
    {
        echo "=== System Information ==="
        echo "Date: $(date)"
        echo "Hostname: $(hostname)"
        echo "User: $(whoami)"
        echo "Home: $HOME"
        echo "Shell: $SHELL"
        echo "ZSH Version: $ZSH_VERSION"
        echo
        
        echo "=== Hardware Information ==="
        if [[ "$(uname)" == "Darwin" ]]; then
            # Sanitize system profiler output line by line
            system_profiler SPHardwareDataType 2>/dev/null | grep -E "Model|Processor|Memory|Serial" | while IFS= read -r line; do
                echo "$(sanitize "$line")"
            done
            echo
            echo "=== macOS Version ==="
            sw_vers
            echo
            echo "=== System Integrity Protection ==="
            csrutil status 2>/dev/null || echo "Unable to check SIP status"
        else
            echo "=== Linux System Info ==="
            uname -a
            lsb_release -a 2>/dev/null || cat /etc/os-release 2>/dev/null || echo "Distribution info not available"
            echo
            echo "=== CPU Info ==="
            lscpu 2>/dev/null | head -20 || echo "CPU info not available"
            echo
            echo "=== Memory Info ==="
            free -h 2>/dev/null || echo "Memory info not available"
        fi
        
        echo
        echo "=== Disk Usage ==="
        df -h | head -20
        
        echo
        echo "=== Network Interfaces ==="
        # Network interfaces with sanitization
        if command -v ifconfig >/dev/null 2>&1; then
            ifconfig 2>/dev/null | grep -E "^[a-z]|inet" | while IFS= read -r line; do
                echo "$(sanitize "$line")"
            done
        elif command -v ip >/dev/null 2>&1; then
            ip addr 2>/dev/null | while IFS= read -r line; do
                echo "$(sanitize "$line")"
            done
        else
            echo "Network interface information not available"
        fi
        
        echo
        echo "=== Process Count ==="
        ps aux | wc -l
        
        echo
        echo "=== Load Average ==="
        uptime
        
    } > "$sys_file"
    
    # Collect environment variables (sanitized)
    {
        echo "=== Environment Variables (Sanitized) ==="
        env | sort | grep -v -E "TOKEN|SECRET|KEY|PASSWORD|CREDENTIAL" | while IFS= read -r line; do
            echo "$(sanitize "$line")"
        done
    } > "$REPORT_DIR/system/environment.txt"
    
    # Collect PATH information
    {
        echo "=== PATH Analysis ==="
        echo "PATH entries:"
        echo "$PATH" | tr ':' '\n' | nl
        echo
        echo "=== Executable Directories ==="
        echo "$PATH" | tr ':' '\n' | while read -r dir; do
            if [[ -d "$dir" ]]; then
                echo "$dir: $(ls -1 "$dir" 2>/dev/null | wc -l) executables"
            fi
        done
    } > "$REPORT_DIR/system/path_info.txt"
    
    log SUCCESS "System information collected"
}

#######################################
# Collect software versions
#######################################
collect_software_versions() {
    log PROGRESS "Collecting software versions"
    
    local ver_file="$REPORT_DIR/system/versions.txt"
    
    {
        echo "=== Core Tools ==="
        
        # Shell
        echo -n "zsh: "
        zsh --version 2>/dev/null | head -1 || echo "not found"
        
        echo -n "bash: "
        bash --version 2>/dev/null | head -1 || echo "not found"
        
        # Editors
        echo
        echo "=== Editors ==="
        
        echo -n "nvim: "
        nvim --version 2>/dev/null | head -1 || echo "not found"
        
        echo -n "vim: "
        vim --version 2>/dev/null | head -1 | cut -d' ' -f1-5 || echo "not found"
        
        # Version control
        echo
        echo "=== Version Control ==="
        
        echo -n "git: "
        git --version 2>/dev/null || echo "not found"
        
        echo -n "gh: "
        gh --version 2>/dev/null | head -1 || echo "not found"

        echo -n "git-lfs: "
        git-lfs --version 2>/dev/null || echo "not found"

        echo -n "gitleaks: "
        gitleaks version 2>/dev/null || echo "not found"

        echo -n "pre-commit: "
        pre-commit --version 2>/dev/null || echo "not found"
        
        # Terminal multiplexers
        echo
        echo "=== Terminal Tools ==="
        
        echo -n "tmux: "
        tmux -V 2>/dev/null || echo "not found"
        
        echo -n "screen: "
        screen --version 2>/dev/null | head -1 || echo "not found"
        
        # Package managers
        echo
        echo "=== Package Managers ==="
        
        if command -v brew >/dev/null 2>&1; then
            echo -n "homebrew: "
            brew --version 2>/dev/null | head -1
            echo "Homebrew packages: $(brew list 2>/dev/null | wc -l)"
        fi
        
        if command -v apt >/dev/null 2>&1; then
            echo -n "apt: "
            apt --version 2>/dev/null | head -1
        fi
        
        if command -v yum >/dev/null 2>&1; then
            echo -n "yum: "
            yum --version 2>/dev/null | head -1
        fi
        
        # Programming languages
        echo
        echo "=== Programming Languages ==="
        
        echo -n "python: "
        python3 --version 2>/dev/null || python --version 2>/dev/null || echo "not found"
        
        echo -n "node: "
        node --version 2>/dev/null || echo "not found"
        
        echo -n "ruby: "
        ruby --version 2>/dev/null || echo "not found"
        
        echo -n "go: "
        go version 2>/dev/null || echo "not found"
        
        echo -n "rust: "
        rustc --version 2>/dev/null || echo "not found"
        
        echo -n "java: "
        java --version 2>&1 | head -1 || echo "not found"
        
        # Terminal emulators and shells
        echo
        echo "=== Terminal Emulators & Shells ==="

        echo -n "alacritty: "
        alacritty --version 2>/dev/null || echo "not found"

        echo -n "wezterm: "
        wezterm --version 2>/dev/null || echo "not found"

        echo -n "kitty: "
        kitty --version 2>/dev/null || echo "not found"

        echo -n "starship: "
        starship --version 2>/dev/null | head -1 || echo "not found"

        echo -n "fish: "
        fish --version 2>/dev/null || echo "not found"

        # Development tools
        echo
        echo "=== Development Tools ==="

        echo -n "make: "
        make --version 2>/dev/null | head -1 || echo "not found"

        echo -n "cmake: "
        cmake --version 2>/dev/null | head -1 || echo "not found"

        echo -n "gcc: "
        gcc --version 2>/dev/null | head -1 || echo "not found"

        echo -n "clang: "
        clang --version 2>/dev/null | head -1 || echo "not found"

        echo -n "cargo: "
        cargo --version 2>/dev/null || echo "not found"

        echo -n "npm: "
        npm --version 2>/dev/null || echo "not found"

        echo -n "yarn: "
        yarn --version 2>/dev/null || echo "not found"

        echo -n "pnpm: "
        pnpm --version 2>/dev/null || echo "not found"

        echo -n "pip: "
        pip3 --version 2>/dev/null || pip --version 2>/dev/null || echo "not found"

        echo -n "poetry: "
        poetry --version 2>/dev/null || echo "not found"

        echo -n "pyenv: "
        pyenv --version 2>/dev/null || echo "not found"

        echo -n "rbenv: "
        rbenv --version 2>/dev/null || echo "not found"

        echo -n "nvm: "
        nvm --version 2>/dev/null || echo "not found"

        echo -n "rustup: "
        rustup --version 2>/dev/null || echo "not found"

        # Code quality tools
        echo
        echo "=== Code Quality Tools ==="

        echo -n "shellcheck: "
        shellcheck --version 2>/dev/null | grep version || echo "not found"

        echo -n "stylua: "
        stylua --version 2>/dev/null || echo "not found"

        echo -n "ruff: "
        ruff --version 2>/dev/null || echo "not found"

        echo -n "black: "
        black --version 2>/dev/null || echo "not found"

        echo -n "prettier: "
        prettier --version 2>/dev/null || echo "not found"

        echo -n "eslint: "
        eslint --version 2>/dev/null || echo "not found"

        echo -n "shfmt: "
        shfmt --version 2>/dev/null || echo "not found"

        # File utilities
        echo
        echo "=== File Utilities ==="

        echo -n "fd: "
        # Suppress Santa blocking messages on macOS
        { fd --version 2>&1 | grep -v "Santa" | grep -v "blocked" | head -1; } 2>/dev/null || echo "not found"

        echo -n "rg (ripgrep): "
        rg --version 2>/dev/null | head -1 || echo "not found"

        echo -n "fzf: "
        fzf --version 2>/dev/null || echo "not found"

        echo -n "bat: "
        bat --version 2>/dev/null || echo "not found"

        echo -n "eza: "
        eza --version 2>/dev/null || echo "not found"

        echo -n "tree: "
        tree --version 2>/dev/null || echo "not found"

        echo -n "jq: "
        jq --version 2>/dev/null || echo "not found"

        echo -n "yq: "
        yq --version 2>/dev/null || echo "not found"

        # Cloud tools
        echo
        echo "=== Cloud & Container Tools ==="

        echo -n "docker: "
        docker --version 2>/dev/null || echo "not found"

        echo -n "docker-compose: "
        docker-compose --version 2>/dev/null || echo "not found"

        echo -n "kubectl: "
        kubectl version --client --short 2>/dev/null || echo "not found"

        echo -n "terraform: "
        terraform version 2>/dev/null | head -1 || echo "not found"

        echo -n "aws: "
        aws --version 2>/dev/null || echo "not found"

        echo -n "gcloud: "
        gcloud --version 2>/dev/null | head -1 || echo "not found"

        echo -n "azure: "
        az --version 2>/dev/null | head -1 || echo "not found"

        # Database clients
        echo
        echo "=== Database Clients ==="

        echo -n "psql: "
        psql --version 2>/dev/null || echo "not found"

        echo -n "mysql: "
        mysql --version 2>/dev/null || echo "not found"

        echo -n "sqlite3: "
        sqlite3 --version 2>/dev/null || echo "not found"

        echo -n "redis-cli: "
        redis-cli --version 2>/dev/null || echo "not found"

        echo -n "mongosh: "
        mongosh --version 2>/dev/null || echo "not found"

        # AI/ML tools
        echo
        echo "=== AI/ML Tools ==="

        echo -n "ollama: "
        ollama --version 2>/dev/null || echo "not found"

        echo -n "cortex: "
        cortex --version 2>/dev/null || echo "not found"

        echo -n "brain: "
        brain --version 2>/dev/null || echo "not found"

        # System utilities
        echo
        echo "=== System Utilities ==="

        echo -n "htop: "
        htop --version 2>/dev/null || echo "not found"

        echo -n "btop: "
        btop --version 2>/dev/null || echo "not found"

        echo -n "ncdu: "
        ncdu --version 2>/dev/null || echo "not found"

        echo -n "wget: "
        wget --version 2>/dev/null | head -1 || echo "not found"

        echo -n "curl: "
        curl --version 2>/dev/null | head -1 || echo "not found"

        echo -n "rsync: "
        rsync --version 2>/dev/null | head -1 || echo "not found"

        echo -n "ssh: "
        ssh -V 2>&1 || echo "not found"

        echo -n "openssl: "
        openssl version 2>/dev/null || echo "not found"

        # macOS specific tools
        if [[ "$(uname)" == "Darwin" ]]; then
            echo
            echo "=== macOS Tools ==="

            echo -n "xcode-select: "
            xcode-select --version 2>/dev/null || echo "not found"

            echo -n "xcrun: "
            xcrun --version 2>/dev/null || echo "not found"

            echo -n "mas: "
            mas version 2>/dev/null || echo "not found"

            echo -n "defaults: "
            echo "$(defaults read -g AppleInterfaceStyle 2>/dev/null || echo "Light") mode"
        fi

        # Language servers
        echo
        echo "=== Language Servers ==="

        echo -n "pyright: "
        pyright --version 2>/dev/null || echo "not found"

        echo -n "typescript-language-server: "
        typescript-language-server --version 2>/dev/null || echo "not found"

        echo -n "rust-analyzer: "
        rust-analyzer --version 2>/dev/null || echo "not found"

        echo -n "gopls: "
        gopls version 2>/dev/null | head -1 || echo "not found"

        echo -n "clangd: "
        clangd --version 2>/dev/null || echo "not found"

        echo -n "lua-language-server: "
        lua-language-server --version 2>/dev/null || echo "not found"

        echo -n "yaml-language-server: "
        yaml-language-server --version 2>/dev/null || echo "not found"

        echo -n "vscode-json-language-server: "
        vscode-json-language-server --version 2>/dev/null || echo "not found"

        echo -n "bash-language-server: "
        bash-language-server --version 2>/dev/null || echo "not found"

        echo -n "dockerfile-language-server: "
        docker-langserver --version 2>/dev/null || echo "not found"

        # Neovim related tools
        echo
        echo "=== Neovim Tools ==="

        echo -n "neovide: "
        neovide --version 2>/dev/null || echo "not found"

        echo -n "nvim-qt: "
        nvim-qt --version 2>/dev/null || echo "not found"

        echo -n "luarocks: "
        luarocks --version 2>/dev/null | head -1 || echo "not found"

        echo -n "luajit: "
        luajit -v 2>/dev/null || echo "not found"

        echo -n "tree-sitter: "
        tree-sitter --version 2>/dev/null || echo "not found"
        
    } > "$ver_file"
    
    # Detailed package lists
    if command -v brew >/dev/null 2>&1; then
        log DEBUG "Collecting Homebrew packages"
        brew list --versions > "$REPORT_DIR/system/brew_packages.txt" 2>/dev/null
        brew list --cask --versions > "$REPORT_DIR/system/brew_casks.txt" 2>/dev/null
    fi
    
    if command -v pip3 >/dev/null 2>&1; then
        log DEBUG "Collecting Python packages"
        pip3 list > "$REPORT_DIR/system/pip_packages.txt" 2>/dev/null
    fi
    
    if command -v npm >/dev/null 2>&1; then
        log DEBUG "Collecting npm packages"
        npm list -g --depth=0 > "$REPORT_DIR/system/npm_packages.txt" 2>/dev/null
    fi
    
    log SUCCESS "Software versions collected"
}

#######################################
# Collect dotfiles configuration
#######################################
collect_dotfiles_config() {
    log PROGRESS "Collecting dotfiles configuration"

    log DEBUG "Collecting git info"
    # Git information
    {
        echo "=== Git Repository Info ==="
        cd "$DOTFILES_DIR"
        echo "Remote: $(git remote -v 2>/dev/null | head -1)"
        echo "Branch: $(git branch --show-current 2>/dev/null)"
        echo "Last commit: $(git log -1 --oneline 2>/dev/null)"
        echo "Status:"
        git status --short 2>/dev/null
        echo
        echo "=== Submodules ==="
        git submodule status 2>/dev/null || echo "No submodules"
    } > "$REPORT_DIR/config/git_info.txt"

    log DEBUG "Collecting directory structure"
    # Directory structure (with timeout)
    {
        echo "=== Dotfiles Structure ==="
        timeout 3 tree -L 3 "$DOTFILES_DIR" 2>/dev/null || timeout 3 find "$DOTFILES_DIR" -maxdepth 3 -type d 2>/dev/null | sort | head -100
    } > "$REPORT_DIR/config/structure.txt"

    log DEBUG "Collecting symlinks"
    # Symlinks (simpler approach to avoid hanging)
    {
        echo "=== Active Symlinks ==="
        # Just list common dotfile symlinks to avoid hanging
        for item in ~/.zshrc ~/.zshenv ~/.tmux.conf ~/.gitconfig ~/.gitignore ~/.config/nvim ~/.config/alacritty; do
            if [[ -L "$item" ]]; then
                target=$(readlink "$item" 2>/dev/null)
                if [[ "$target" == *"$DOTFILES_DIR"* ]]; then
                    echo "$item -> $target"
                fi
            fi
        done
    } > "$REPORT_DIR/config/symlinks.txt"

    log DEBUG "Collecting configuration file listings"
    # Configuration files (headers only, no content for security)
    {
        echo "=== Configuration Files ==="
        echo
        echo "Neovim config:"
        ls -la "$DOTFILES_DIR/src/neovim/" 2>/dev/null | head -20
        echo
        echo "Zsh config:"
        ls -la "$DOTFILES_DIR/src/zsh/" 2>/dev/null | head -20
        echo
        echo "Scripts:"
        ls -la "$DOTFILES_DIR/src/scripts/" 2>/dev/null
    } > "$REPORT_DIR/config/files.txt"
    
    log SUCCESS "Dotfiles configuration collected"
}

#######################################
# Collect Neovim diagnostics
#######################################
collect_nvim_diagnostics() {
    log PROGRESS "Collecting Neovim diagnostics"
    
    if ! command -v nvim >/dev/null 2>&1; then
        log WARN "Neovim not found, skipping"
        return
    fi
    
    # Basic info
    nvim --version > "$REPORT_DIR/config/nvim_version.txt" 2>&1
    
    # Checkhealth (with timeout to prevent hanging)
    log DEBUG "Running Neovim checkhealth"
    timeout 10 nvim --headless "+checkhealth" "+w! $REPORT_DIR/config/nvim_checkhealth.txt" "+qa!" 2>/dev/null || {
        echo "Neovim checkhealth timed out after 10 seconds" > "$REPORT_DIR/config/nvim_checkhealth.txt"
    }
    
    # Plugin list (with timeout and better error handling)
    {
        echo "=== Lazy.nvim Plugins ==="
        timeout 5 nvim --headless +'lua local ok, lazy = pcall(require, "lazy"); if ok then local stats = lazy.stats(); print("Loaded plugins: " .. stats.loaded .. "/" .. stats.count); print("Startup time: " .. math.floor(stats.startuptime) .. "ms"); for _, plugin in pairs(require("lazy").plugins()) do print("  - " .. plugin.name .. (plugin._.loaded and " [loaded]" or "")); end else print("Lazy.nvim not found") end' +qa! 2>&1 || {
            echo "Unable to get plugin stats (timed out or error)"
            echo "Attempting simpler plugin list..."
            timeout 5 nvim --headless +'redir @a | silent! Lazy | redir END | put a | w!' "$REPORT_DIR/config/nvim_plugins_fallback.txt" +qa! 2>/dev/null || echo "Plugin collection failed"
        }
    } > "$REPORT_DIR/config/nvim_plugins.txt"

    # LSP servers (with timeout and better error handling)
    {
        echo "=== LSP Servers ==="
        timeout 5 nvim --headless +'lua local clients = vim.lsp.get_clients(); if #clients > 0 then for _, client in ipairs(clients) do print("  - " .. client.name .. " (id: " .. client.id .. ")") end else print("No LSP clients active") end' +qa! 2>&1 || {
            echo "Unable to get LSP info (timed out or error)"
            # Try to at least get installed servers from Mason
            echo "Checking Mason installed servers..."
            timeout 5 nvim --headless +'lua local ok, mason = pcall(require, "mason-registry"); if ok then local installed = mason.get_installed_package_names(); for _, pkg in ipairs(installed) do print("  - " .. pkg) end else print("Mason not available") end' +qa! 2>/dev/null || echo "LSP collection failed"
        }
    } > "$REPORT_DIR/config/nvim_lsp.txt"

    # Critical Neovim health checks
    {
        echo "=== Critical Neovim Checks ==="
        echo
        echo "== Startup Errors =="
        if [[ -f ~/.local/state/nvim/startup_errors.log ]]; then
            # Filter out old vim plugin errors (Glug, maktaba, csimporter)
            # These are from /usr/share/vim/google and don't affect Neovim
            local error_count=$(tail -50 ~/.local/state/nvim/startup_errors.log 2>/dev/null | \
                grep -v "csimporter\|Glug settings\|maktaba" | \
                grep -c "ERROR\|Error" || echo 0)

            if [[ "$error_count" -gt 0 ]]; then
                echo "Found $error_count Neovim startup errors (excluding old vim plugin errors):"
                tail -50 ~/.local/state/nvim/startup_errors.log 2>/dev/null | \
                    grep -v "csimporter\|Glug settings\|maktaba" || echo "No relevant errors"
            else
                echo "No Neovim startup errors (old vim plugin errors excluded)"
            fi
        else
            echo "No startup error log found"
        fi
        echo
        echo "== Provider Health =="
        timeout 5 nvim --headless -c "echo 'Python3: ' . has('python3')" -c "echo 'Node: ' . has('node')" -c "qa!" 2>&1 || echo "Provider check failed"
        echo
        echo "== Critical Plugins Status =="
        timeout 5 nvim --headless -c "lua local ok, err = pcall(require, 'blink.cmp'); print('blink.cmp:', ok and 'OK' or err)" -c "qa!" 2>&1 || echo "blink.cmp check failed"
        timeout 5 nvim --headless -c "lua local ok, err = pcall(require, 'lspconfig'); print('lspconfig:', ok and 'OK' or err)" -c "qa!" 2>&1 || echo "lspconfig check failed"
        timeout 5 nvim --headless -c "lua local ok, err = pcall(require, 'telescope'); print('telescope:', ok and 'OK' or err)" -c "qa!" 2>&1 || echo "telescope check failed"
        echo
        echo "== Work Configuration Check =="
        if [[ -d "$HOME/.dotfiles/.dotfiles.private" ]]; then
            echo "Private dotfiles: FOUND"
            if [[ -f "$HOME/.dotfiles/.dotfiles.private/companies/google/neovim/config/lsp/servers.lua" ]]; then
                echo "Google LSP config: FOUND"
            else
                echo "Google LSP config: NOT FOUND"
            fi
        else
            echo "Private dotfiles: NOT FOUND"
        fi
        echo
        echo "== Common Issues Check =="
        # Check for common Neovim issues
        echo "Swap files:"
        find ~/.local/state/nvim/swap -name "*.swp" 2>/dev/null | wc -l || echo "0"
        echo "Shada file size:"
        du -h ~/.local/state/nvim/shada/main.shada 2>/dev/null || echo "No shada file"
        echo "Lazy.nvim lock file:"
        if [[ -f "$DOTFILES_DIR/src/neovim/lazy-lock.json" ]]; then
            echo "Present ($(wc -l < "$DOTFILES_DIR/src/neovim/lazy-lock.json") lines)"
        else
            echo "Not found"
        fi
    } > "$REPORT_DIR/config/nvim_critical_checks.txt"

    log SUCCESS "Neovim diagnostics collected"
}

#######################################
# Collect shell diagnostics
#######################################
collect_shell_diagnostics() {
    log PROGRESS "Collecting shell diagnostics"
    
    # Zsh configuration
    {
        echo "=== Zsh Configuration ==="
        echo "ZDOTDIR: ${ZDOTDIR:-not set}"
        echo "Config files:"
        ls -la ~/.z* 2>/dev/null | grep -E "zsh|zprofile|zlogin"
        echo
        echo "=== Zsh Modules ==="
        zmodload 2>/dev/null || echo "Unable to list modules"
        echo
        echo "=== Zsh Options ==="
        setopt 2>/dev/null | head -50
    } > "$REPORT_DIR/config/zsh_config.txt"
    
    # Shell startup time (with timeout to prevent hanging on initialization)
    {
        echo "=== Shell Startup Time ==="
        echo "Testing zsh startup..."

        # Check if we can use high-resolution timer
        if date +%s%N >/dev/null 2>&1; then
            # High-resolution timing available (Linux)
            local start=$(date +%s%N)
            timeout 5 zsh -i -c exit 2>/dev/null
            local exit_code=$?
            local end=$(date +%s%N)
            if [[ $exit_code -eq 124 ]]; then
                echo "Interactive shell startup: TIMEOUT (>5s)"
            else
                local elapsed=$(( (end - start) / 1000000 ))
                echo "Interactive shell startup: ${elapsed}ms"
            fi

            start=$(date +%s%N)
            timeout 2 zsh -c exit 2>/dev/null
            exit_code=$?
            end=$(date +%s%N)
            if [[ $exit_code -eq 124 ]]; then
                echo "Non-interactive shell startup: TIMEOUT (>2s)"
            else
                elapsed=$(( (end - start) / 1000000 ))
                echo "Non-interactive shell startup: ${elapsed}ms"
            fi
        else
            # Fallback to second resolution (macOS)
            echo "Note: High-resolution timer not available, using second resolution"
            local start=$(date +%s)
            timeout 5 zsh -i -c exit 2>/dev/null
            local exit_code=$?
            local end=$(date +%s)
            if [[ $exit_code -eq 124 ]]; then
                echo "Interactive shell startup: TIMEOUT (>5s)"
            else
                local elapsed=$(( end - start ))
                echo "Interactive shell startup: ~${elapsed}s"
            fi

            start=$(date +%s)
            timeout 2 zsh -c exit 2>/dev/null
            exit_code=$?
            end=$(date +%s)
            if [[ $exit_code -eq 124 ]]; then
                echo "Non-interactive shell startup: TIMEOUT (>2s)"
            else
                elapsed=$(( end - start ))
                echo "Non-interactive shell startup: ~${elapsed}s"
            fi
        fi

        # Additional timing using built-in time command if available
        echo
        echo "=== Detailed Timing (using time command) ==="
        echo "Interactive shell:"
        (time timeout 5 zsh -i -c exit) 2>&1 | grep -E "real|user|sys" || echo "Time command not available"
        echo
        echo "Non-interactive shell:"
        (time timeout 2 zsh -c exit) 2>&1 | grep -E "real|user|sys" || echo "Time command not available"
    } > "$REPORT_DIR/debug/shell_performance.txt"
    
    # Aliases and functions count
    {
        echo "=== Shell Environment ==="
        echo "Aliases: $(alias | wc -l)"
        echo "Functions: $(functions | wc -l)"
        echo "Completion functions: $(print -l $fpath | wc -l)"
    } > "$REPORT_DIR/config/shell_env.txt"
    
    log SUCCESS "Shell diagnostics collected"
}

#######################################
# Collect terminal information
#######################################
collect_terminal_info() {
    log PROGRESS "Collecting terminal information"
    
    {
        echo "=== Terminal Environment ==="
        echo "TERM: $TERM"
        echo "TERM_PROGRAM: ${TERM_PROGRAM:-not set}"
        echo "COLORTERM: ${COLORTERM:-not set}"
        echo "Terminal size: $(tput cols)x$(tput lines)"
        echo
        echo "=== Terminal Capabilities ==="
        echo "Colors: $(tput colors)"
        infocmp -1 2>/dev/null | head -20 || echo "Unable to get terminfo"
    } > "$REPORT_DIR/config/terminal.txt"
    
    # Alacritty config
    if [[ -f ~/.config/alacritty/alacritty.toml ]]; then
        echo "Found Alacritty config" > "$REPORT_DIR/config/alacritty_info.txt"
        head -50 ~/.config/alacritty/alacritty.toml >> "$REPORT_DIR/config/alacritty_info.txt" 2>/dev/null
    fi
    
    # tmux config with enhanced health check
    if command -v tmux >/dev/null 2>&1; then
        {
            echo "=== tmux Information ==="
            tmux -V
            echo "Config file: ${TMUX_CONF:-~/.tmux.conf}"
            echo "Sessions: $(tmux ls 2>/dev/null | wc -l)"
            echo
            echo "=== tmux Server Info ==="
            tmux info 2>/dev/null | head -50 || echo "Unable to get tmux info"
            echo
            echo "=== tmux Plugins (if TPM installed) ==="
            if [[ -d ~/.tmux/plugins/tpm ]]; then
                ls -la ~/.tmux/plugins/ 2>/dev/null | head -20
            else
                echo "TPM not installed"
            fi
        } > "$REPORT_DIR/config/tmux_info.txt"
    fi

    log DEBUG "Checking for Starship"
    # Starship prompt health check
    if command -v starship >/dev/null 2>&1; then
        log DEBUG "Collecting Starship info"
        {
            echo "=== Starship Information ==="
            starship --version
            echo
            echo "=== Starship Config Location ==="
            echo "Config: ~/.config/starship.toml"
            echo
            echo "=== Starship Module Status ==="
            timeout 2 starship module --list 2>/dev/null || echo "Unable to list modules"
        } > "$REPORT_DIR/config/starship_info.txt"
    fi

    # WezTerm health check
    if command -v wezterm >/dev/null 2>&1; then
        {
            echo "=== WezTerm Information ==="
            wezterm --version
            echo
            echo "=== WezTerm Config Location ==="
            echo "Config dir: ~/.config/wezterm/"
            ls -la ~/.config/wezterm/ 2>/dev/null | head -10 || echo "Config directory not found"
        } > "$REPORT_DIR/config/wezterm_info.txt"
    fi

    log DEBUG "Checking for Homebrew"
    # Homebrew doctor (health check)
    if command -v brew >/dev/null 2>&1; then
        log DEBUG "Running Homebrew doctor (limited)"
        {
            echo "=== Homebrew Doctor (Critical Issues Only) ==="
            timeout 10 brew doctor 2>&1 | { grep -E "Warning|Error|Critical" | head -50 || echo "No critical issues found"; }
            echo
            echo "=== Homebrew Config ==="
            brew config 2>&1 | head -30 || echo "Unable to get config"
        } > "$REPORT_DIR/config/brew_health.txt"
    fi

    # Git health check
    {
        echo "=== Git Configuration Health ==="
        git config --list --show-origin 2>/dev/null | grep -E "user\.|core\.|push\." | head -30 || echo "Unable to list git config"
        echo
        echo "=== Git Hooks ==="
        if [[ -d "$DOTFILES_DIR/.git/hooks" ]]; then
            ls -la "$DOTFILES_DIR/.git/hooks/" 2>/dev/null | grep -v sample
        else
            echo "No git hooks directory"
        fi
        echo
        echo "=== Git Aliases ==="
        git config --get-regexp alias 2>/dev/null | head -20 || echo "No aliases found"
    } > "$REPORT_DIR/config/git_health.txt"

    # Python/pip health check
    if command -v python3 >/dev/null 2>&1; then
        {
            echo "=== Python Health Check ==="
            python3 --version
            echo "Python path: $(which python3)"
            echo
            echo "=== Pip Check (Dependency Conflicts) ==="
            timeout 5 python3 -m pip check 2>&1 || echo "Pip check failed or timed out"
            echo
            echo "=== Python Site Packages ==="
            python3 -c "import site; print('\n'.join(site.getsitepackages()))" 2>/dev/null || echo "Unable to get site packages"
        } > "$REPORT_DIR/config/python_health.txt"
    fi

    # Node/npm health check
    if command -v npm >/dev/null 2>&1; then
        {
            echo "=== Node/NPM Health Check ==="
            node --version
            npm --version
            echo "NPM prefix: $(npm config get prefix 2>/dev/null)"
            echo
            echo "=== NPM Doctor ==="
            timeout 10 npm doctor 2>&1 | head -50 || echo "NPM doctor timed out or failed"
            echo
            echo "=== NPM Cache Verify ==="
            timeout 5 npm cache verify 2>&1 || echo "Cache verify timed out"
        } > "$REPORT_DIR/config/npm_health.txt"
    fi

    # Rust/Cargo health check
    if command -v cargo >/dev/null 2>&1; then
        {
            echo "=== Rust/Cargo Health Check ==="
            rustc --version 2>/dev/null || echo "rustc not found"
            cargo --version
            echo
            echo "=== Rustup Show ==="
            rustup show 2>/dev/null | head -30 || echo "rustup not available"
            echo
            echo "=== Cargo Config ==="
            cat ~/.cargo/config.toml 2>/dev/null | head -20 || echo "No cargo config found"
        } > "$REPORT_DIR/config/rust_health.txt"
    fi

    # Cortex/Brain AI tool health check
    if command -v cortex >/dev/null 2>&1 || command -v brain >/dev/null 2>&1; then
        {
            echo "=== AI Tool Health Check ==="
            if command -v cortex >/dev/null 2>&1; then
                echo "Tool: cortex"
                cortex --version 2>/dev/null || echo "Version not available"
                echo
                echo "=== Cortex Status ==="
                timeout 5 cortex status 2>&1 || echo "Status check timed out"
                echo
                echo "=== Cortex Health ==="
                timeout 5 cortex health -v 2>&1 || echo "Health check timed out"
            elif command -v brain >/dev/null 2>&1; then
                echo "Tool: brain"
                brain --version 2>/dev/null || echo "Version not available"
                echo
                echo "=== Brain Status ==="
                timeout 5 brain status 2>&1 || echo "Status check timed out"
            fi
        } > "$REPORT_DIR/config/ai_tools_health.txt"
    fi

    # Zsh completions health check
    {
        echo "=== Zsh Completions Health ==="
        echo "Completion paths:"
        echo "$fpath" | tr ' ' '\n' | head -20
        echo
        echo "=== Completion Files Count ==="
        for dir in ${fpath[@]}; do
            if [[ -d "$dir" ]]; then
                echo "$dir: $(ls "$dir" 2>/dev/null | wc -l) files"
            fi
        done 2>/dev/null | head -20
    } > "$REPORT_DIR/config/zsh_completions.txt"

    # LSP servers health check (via Neovim)
    if command -v nvim >/dev/null 2>&1; then
        {
            echo "=== LSP Servers Health Check ==="
            timeout 5 nvim --headless -c "lua print(vim.lsp.get_log_path())" -c "qa!" 2>&1 || echo "Unable to get LSP log path"
            echo
            echo "=== Available LSP Configs ==="
            timeout 5 nvim --headless -c "lua for k,_ in pairs(require('lspconfig').util.available_servers()) do print(k) end" -c "qa!" 2>&1 || echo "Unable to list LSP configs"
            echo
            echo "=== Mason Installed Servers ==="
            if [[ -d ~/.local/share/nvim/mason/bin ]]; then
                ls -la ~/.local/share/nvim/mason/bin/ 2>/dev/null | head -20 || echo "No Mason binaries found"
            else
                echo "Mason not installed or no binaries"
            fi
        } > "$REPORT_DIR/config/lsp_health.txt"
    fi

    # Font and ligature support check
    {
        echo "=== Font Configuration ==="
        if [[ "$(uname)" == "Darwin" ]]; then
            echo "Default terminal font:"
            defaults read com.apple.Terminal "Default Window Settings" 2>/dev/null | grep -A2 Font | head -5 || echo "Unable to get terminal font"
            echo
            echo "Installed Nerd Fonts:"
            fc-list 2>/dev/null | grep -i "nerd" | head -10 || echo "fc-list not available"
        else
            echo "Terminal fonts with ligatures:"
            fc-list :spacing=mono 2>/dev/null | grep -E "Fira|JetBrains|Cascadia|Iosevka|Victor" | head -10 || echo "No ligature fonts found"
        fi
    } > "$REPORT_DIR/config/font_info.txt"

    # Performance metrics
    {
        echo "=== Performance Metrics ==="
        echo "Current memory usage:"
        if [[ "$(uname)" == "Darwin" ]]; then
            vm_stat 2>/dev/null | head -10 || echo "Unable to get memory stats"
        else
            free -h 2>/dev/null || echo "Unable to get memory stats"
        fi
        echo
        echo "=== Top Memory Consumers ==="
        ps aux | sort -rn -k 4 | head -10 2>/dev/null || echo "Unable to get process memory usage"
    } > "$REPORT_DIR/debug/performance_metrics.txt"

    log SUCCESS "Terminal information and health checks collected"
}

#######################################
# Collect system logs
#######################################
collect_logs() {
    if [[ $INCLUDE_LOGS -eq 0 ]]; then
        log INFO "Skipping log collection (--no-logs specified)"
        return
    fi
    
    log PROGRESS "Collecting relevant logs"
    
    # Dotfiles logs
    if [[ -d "$DOTFILES_DIR/test/logs" ]]; then
        log DEBUG "Copying test logs"
        cp -r "$DOTFILES_DIR/test/logs" "$REPORT_DIR/logs/test_logs" 2>/dev/null
    fi
    
    # Neovim logs
    if [[ -d ~/.local/state/nvim ]]; then
        log DEBUG "Collecting Neovim logs"
        find ~/.local/state/nvim -name "*.log" -type f -mtime -7 -exec cp {} "$REPORT_DIR/logs/" \; 2>/dev/null
    fi
    
    # System logs (last 100 lines, sanitized)
    if [[ "$(uname)" == "Darwin" ]]; then
        log DEBUG "Collecting macOS system logs (limited to 5 seconds)"
        timeout 5 log show --style syslog --last 5m 2>/dev/null | tail -100 | while IFS= read -r line; do
            echo "$(sanitize "$line")"
        done > "$REPORT_DIR/logs/system.log" || {
            echo "System log collection timed out" > "$REPORT_DIR/logs/system.log"
        }
    else
        # Linux system logs
        if [[ -r /var/log/syslog ]]; then
            tail -100 /var/log/syslog | while IFS= read -r line; do
                echo "$(sanitize "$line")"
            done > "$REPORT_DIR/logs/system.log" 2>/dev/null
        elif [[ -r /var/log/messages ]]; then
            tail -100 /var/log/messages | while IFS= read -r line; do
                echo "$(sanitize "$line")"
            done > "$REPORT_DIR/logs/system.log" 2>/dev/null
        fi
    fi
    
    log SUCCESS "Logs collected"
}

#######################################
# Run tests if requested
#######################################
run_tests() {
    if [[ $TEST_MODE -eq 0 ]]; then
        return
    fi
    
    log PROGRESS "Running tests (size: $TEST_SIZE)"

    # Look for test runner in multiple locations
    local test_runner=""
    if [[ -x "$DOTFILES_DIR/test/runner.zsh" ]]; then
        test_runner="$DOTFILES_DIR/test/runner.zsh"
    elif [[ -x "$DOTFILES_DIR/test/run" ]]; then
        test_runner="$DOTFILES_DIR/test/run"
    else
        log WARN "Test runner not found in any expected location"
        echo "Test runner not found. Checked:" > "$REPORT_DIR/tests/test_results.txt"
        echo "  - $DOTFILES_DIR/test/runner.zsh" >> "$REPORT_DIR/tests/test_results.txt"
        echo "  - $DOTFILES_DIR/test/run" >> "$REPORT_DIR/tests/test_results.txt"
        return
    fi
    
    # Run tests with appropriate size
    local test_output="$REPORT_DIR/tests/test_results.txt"
    local test_args="--${TEST_SIZE}"
    
    [[ $DEBUG_MODE -eq 1 ]] && test_args="$test_args --debug"
    
    log INFO "Executing: $test_runner $test_args"
    
    # Run tests and capture output
    if $test_runner $test_args > "$test_output" 2>&1; then
        log SUCCESS "Tests completed successfully"
    else
        log WARN "Some tests failed (see test_results.txt)"
    fi
    
    # Also generate test report in different formats
    $test_runner $test_args --output=json > "$REPORT_DIR/tests/results.json" 2>/dev/null || true
    $test_runner $test_args --output=junit > "$REPORT_DIR/tests/results.xml" 2>/dev/null || true
}

#######################################
# Validate dotfiles configuration
#######################################
validate_configuration() {
    log PROGRESS "Validating dotfiles configuration"

    {
        echo "=== Configuration Validation ==="
        echo
        echo "== Symlink Health =="
        local broken_links=0
        for link in ~/.zshrc ~/.zshenv ~/.tmux.conf ~/.gitconfig ~/.gitignore ~/.config/nvim; do
            if [[ -L "$link" ]]; then
                if [[ ! -e "$link" ]]; then
                    echo "BROKEN: $link -> $(readlink "$link")"
                    ((broken_links++))
                else
                    echo "OK: $link"
                fi
            elif [[ -e "$link" ]]; then
                echo "WARNING: $link exists but is not a symlink"
            else
                echo "MISSING: $link"
            fi
        done
        echo "Broken symlinks: $broken_links"

        echo
        echo "== Required Directories =="
        for dir in ~/.config ~/.local/share/nvim ~/.local/state/nvim ~/.cache/nvim; do
            if [[ -d "$dir" ]]; then
                echo "OK: $dir"
            else
                echo "MISSING: $dir"
            fi
        done

        echo
        echo "== Critical Files =="
        for file in "$DOTFILES_DIR/src/neovim/init.lua" "$DOTFILES_DIR/src/zsh/zshrc" "$DOTFILES_DIR/src/scripts/common.sh"; do
            if [[ -f "$file" ]]; then
                echo "OK: $file ($(wc -l < "$file") lines)"
            else
                echo "MISSING: $file"
            fi
        done

        echo
        echo "== Known Issues from Healthcheck =="
        # Parse the checkhealth output for errors
        if [[ -f "$REPORT_DIR/config/nvim_checkhealth.txt" ]]; then
            grep -E "ERROR|FAIL|WARNING" "$REPORT_DIR/config/nvim_checkhealth.txt" | head -20 || echo "No issues found in checkhealth"
        else
            echo "Checkhealth not available"
        fi

        echo
        echo "== Git Repository Status =="
        cd "$DOTFILES_DIR"
        git status --short | head -20 || echo "Unable to get git status"
        echo "Uncommitted files: $(git status --short | wc -l)"
        echo "Untracked files: $(git ls-files --others --exclude-standard | wc -l)"

        echo
        echo "== Permission Issues =="
        # Check for permission issues on script files (exclude README and other docs)
        for file in "$DOTFILES_DIR/src/scripts/"*; do
            if [[ -f "$file" ]] && [[ ! -x "$file" ]]; then
                # Skip documentation files
                local basename=$(basename "$file")
                if [[ "$basename" != "README.md" ]] && [[ "$basename" != "common.sh" ]] && [[ "$basename" != "*.txt" ]]; then
                    echo "NOT EXECUTABLE: $file"
                fi
            fi
        done
    } > "$REPORT_DIR/config/validation_report.txt"

    log SUCCESS "Configuration validation completed"
}

#######################################
# Collect debug information
#######################################
collect_debug_info() {
    log PROGRESS "Collecting debug information"

    log DEBUG "Collecting process list"
    # Process list
    {
        echo "=== Process Tree ==="
        # Use ps aux on macOS (no -f flag), pstree if available
        pstree 2>/dev/null | head -50 || ps aux 2>/dev/null | head -50 || echo "Unable to get process list"
    } > "$REPORT_DIR/debug/processes.txt"

    log DEBUG "Collecting open files"
    # Open files (with timeout - lsof can be very slow)
    {
        echo "=== Open Files (Sample) ==="
        timeout 3 lsof 2>/dev/null | head -100 | while IFS= read -r line; do
            echo "$(sanitize "$line")"
        done || echo "lsof command timed out"
    } > "$REPORT_DIR/debug/open_files.txt"

    log DEBUG "Collecting network connections"
    # Network connections (with timeout)
    {
        echo "=== Network Connections ==="
        # Network connections with sanitization
        if command -v netstat >/dev/null 2>&1; then
            timeout 2 netstat -an 2>/dev/null | head -50 | while IFS= read -r line; do
                echo "$(sanitize "$line")"
            done
        elif command -v ss >/dev/null 2>&1; then
            timeout 2 ss -an 2>/dev/null | head -50 | while IFS= read -r line; do
                echo "$(sanitize "$line")"
            done
        else
            echo "Network info collection timed out"
        fi
    } > "$REPORT_DIR/debug/network.txt"
    
    # Kernel modules (Linux)
    if [[ "$(uname)" == "Linux" ]]; then
        {
            echo "=== Kernel Modules ==="
            lsmod 2>/dev/null | head -50
        } > "$REPORT_DIR/debug/kernel_modules.txt"
    fi
    
    log DEBUG "Collecting system limits"
    # System limits
    {
        echo "=== System Limits ==="
        ulimit -a
    } > "$REPORT_DIR/debug/limits.txt"

    log SUCCESS "Debug information collected"
}

#######################################
# Create final archive
#######################################
create_archive() {
    log PROGRESS "Creating archive"
    
    # Create README
    cat > "$REPORT_DIR/README.txt" << EOF
Dotfiles Bug Report
Generated: $(date)
Report ID: $TIMESTAMP

This report contains diagnostic information about the dotfiles setup.
All sensitive information has been sanitized (unless --no-sanitize was used).

Contents:
- metadata.json: Report metadata and options
- system/: System and hardware information
- config/: Dotfiles and application configuration
- logs/: Recent log files (if included)
- tests/: Test results (if run)
- debug/: Additional debug information

To extract: tar -xzf $ARCHIVE_NAME
EOF
    
    # Create archive
    cd "$(dirname "$REPORT_DIR")"
    tar -czf "$ARCHIVE_NAME" "$(basename "$REPORT_DIR")"
    
    # Calculate size and file count before cleanup
    local size=$(du -h "$ARCHIVE_NAME" | cut -f1)
    local file_count=$(find "$REPORT_DIR" -type f 2>/dev/null | wc -l)
    local error_count=$(grep -r "ERROR\|FAIL\|WARNING" "$REPORT_DIR" 2>/dev/null | wc -l || echo "0")

    # Store these values globally for the summary (use readonly to prevent issues)
    readonly _BUGREPORT_FILE_COUNT="$file_count"
    readonly _BUGREPORT_ERROR_COUNT="$error_count"
    export _BUGREPORT_FILE_COUNT _BUGREPORT_ERROR_COUNT

    # Clean up directory
    rm -rf "$REPORT_DIR"

    log SUCCESS "Archive created: $ARCHIVE_NAME (${size})"
}

#######################################
# Main execution
#######################################
main() {
    parse_args "$@"
    
    echo "${BOLD}═══════════════════════════════════════════════════════${NC}"
    echo "${BOLD}            Dotfiles Bug Report Generator              ${NC}"
    echo "${BOLD}═══════════════════════════════════════════════════════${NC}"
    echo
    
    # Setup
    setup_report_dir
    
    # Collect information with error handling
    collect_system_info || log WARN "System info collection had errors"
    collect_software_versions || log WARN "Software version collection had errors"
    collect_dotfiles_config || log WARN "Dotfiles config collection had errors"
    collect_nvim_diagnostics || log WARN "Neovim diagnostics collection had errors"
    collect_shell_diagnostics || log WARN "Shell diagnostics collection had errors"
    collect_terminal_info || log WARN "Terminal info collection had errors"
    validate_configuration || log WARN "Configuration validation had errors"
    collect_logs || log WARN "Log collection had errors"
    collect_debug_info || log WARN "Debug info collection had errors"

    # Run tests if requested
    run_tests
    
    # Create summary of what was collected
    {
        echo "=== Collection Summary ==="
        echo "Report generated at: $(date)"
        echo
        echo "Files collected:"
        find "$REPORT_DIR" -type f -name "*.txt" -o -name "*.json" | while read -r file; do
            local size=$(du -h "$file" | cut -f1)
            local lines=$(wc -l < "$file" 2>/dev/null || echo "0")
            echo "  - $(basename "$file"): ${lines} lines (${size})"
        done
        echo
        echo "Errors and warnings found:"
        # Count actual errors/warnings, excluding LSP server messages logged as ERROR
        # Excluded patterns:
        # - I[timestamp] - LSP info messages
        # - E[timestamp] - clangd/LSP server error logs
        # - [timestamp INF] - Marksman info logs
        # - "stderr" lines containing LSP server output
        grep -r "ERROR\|FAIL\|WARNING" "$REPORT_DIR" 2>/dev/null | \
            grep -v "I\[" | \
            grep -v "E\[" | \
            grep -v "\[.*INF\]" | \
            grep -v "\[.*WRN\]" | \
            grep -v '"rpc".*"stderr"' | \
            grep -v "IncludeCleaner" | \
            wc -l || echo "0"
    } > "$REPORT_DIR/collection_summary.txt"

    # Create final archive
    create_archive

    echo
    echo "${BOLD}═══════════════════════════════════════════════════════${NC}"
    echo "${GREEN}Report generation complete!${NC}"
    echo
    echo "Archive: ${BOLD}${ARCHIVE_NAME}${NC}"
    echo "Size: $(du -h "$ARCHIVE_NAME" | cut -f1)"
    echo
    echo "Summary:"
    echo "  - System: $(uname -s) $(uname -r)"
    echo "  - Files collected: ${_BUGREPORT_FILE_COUNT:-0}"
    echo "  - Errors/warnings found: ${_BUGREPORT_ERROR_COUNT:-0}"
    echo
    echo "You can now share this file for debugging purposes."
    echo "All sensitive information has been sanitized."
    echo "${BOLD}═══════════════════════════════════════════════════════${NC}"

    # Ensure we exit with success
    return 0 2>/dev/null || exit 0
}

# Run main function only if script is executed directly
# Zsh way to check if script is being sourced
if [[ "${ZSH_EVAL_CONTEXT}" != *":file" ]] && [[ "${ZSH_EVAL_CONTEXT}" != *":source" ]]; then
    main "$@"
    exit $?
fi