#!/usr/bin/env bash
# Universal code formatter and fixer script
# Works on both macOS and Linux with Google style standards

# Source common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Strict mode
set -euo pipefail

# Configuration
DO_ALL=false
DO_TRAILING=false
DO_TABS=false
DO_QUOTES=false
DO_FORMATTERS=false
VERBOSE=false
DRY_RUN=false
FILES=()

# Check if a file is binary
is_binary_file() {
  local file="${1:?Error: file required}"
  file "$file" | grep -q "binary\|data"
}

# Remove trailing whitespace
remove_trailing_whitespace() {
  local file="${1:?Error: file required}"

  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "[DRY RUN] Would remove trailing whitespace from: $file"
  else
    echo -n "  → Removing trailing whitespace... "
    platform_command \
      "sed -i '' 's/[[:space:]]*$//' '${file}'" \
      "sed -i 's/[[:space:]]*$//' '${file}'"
    print_color green "✓"
  fi
}

# Convert tabs to spaces (Google style: 2 spaces default, 4 for Python)
convert_tabs_to_spaces() {
  local file="${1:?Error: file required}"
  local tab_width=2

  # Python uses 4 spaces per Google style guide
  if [[ "$file" =~ \.(py|pyw|pyi)$ ]]; then
    tab_width=4
  fi

  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "[DRY RUN] Would convert tabs to ${tab_width} spaces in: $file"
  else
    echo -n "  → Converting tabs to ${tab_width} spaces... "
    expand -t "${tab_width}" "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    print_color green "✓"
  fi
}

# Normalize smart quotes to regular quotes
normalize_quotes() {
  local file="${1:?Error: file required}"

  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "[DRY RUN] Would normalize smart quotes in: $file"
  else
    echo -n "  → Normalizing smart quotes... "
    # Use perl for reliable cross-platform Unicode handling
    perl -i -pe 's/\x{2018}/\x27/g; s/\x{2019}/\x27/g; s/\x{201C}/"/g; s/\x{201D}/"/g' "$file" 2>/dev/null || true
    print_color green "✓"
  fi
}

# Format C/C++ files (Google style: 2 spaces, 80 column)
format_cpp() {
  local file="${1:?Error: file required}"

  if has_command clang-format; then
    if [[ "${DRY_RUN}" == true ]]; then
      print_color blue "[DRY RUN] Would run clang-format (Google style) on: $file"
    else
      echo -n "  → Running clang-format (Google style)... "
      clang-format -i -style='{BasedOnStyle: Google, IndentWidth: 2, ColumnLimit: 80}' "$file"
      print_color green "✓"
    fi
  else
    print_color yellow "  ⚠ Skipping C/C++ formatting (clang-format not found)"
    echo "    Install with: $(platform_command 'brew install clang-format' 'sudo apt install clang-format')"
  fi
}

# Format Python files (Google style: 4 spaces, 80 column)
format_python() {
  local file="${1:?Error: file required}"
  local formatted=false

  # Prefer ruff (fast, modern, follows Google style)
  if has_command ruff; then
    if [[ "${DRY_RUN}" == true ]]; then
      print_color blue "[DRY RUN] Would run ruff on: $file"
    else
      echo -n "  → Running ruff check --fix... "
      ruff check --fix "$file" 2>/dev/null || true
      print_color green "✓"

      echo -n "  → Running ruff format... "
      ruff format --line-length 80 "$file"
      print_color green "✓"
      formatted=true
    fi
  elif has_command black; then
    if [[ "${DRY_RUN}" == true ]]; then
      print_color blue "[DRY RUN] Would run black on: $file"
    else
      echo -n "  → Running black... "
      black -q --line-length 80 "$file"
      print_color green "✓"
      formatted=true

      # Also run isort if available
      if has_command isort; then
        echo -n "  → Running isort... "
        isort --profile google --line-length 80 "$file"
        print_color green "✓"
      fi
    fi
  elif has_command yapf; then
    if [[ "${DRY_RUN}" == true ]]; then
      print_color blue "[DRY RUN] Would run yapf on: $file"
    else
      echo -n "  → Running yapf (Google style)... "
      yapf -i --style=google "$file"
      print_color green "✓"
      formatted=true
    fi
  fi

  if [[ "${formatted}" == false ]] && [[ "${DRY_RUN}" == false ]]; then
    print_color yellow "  ⚠ No Python formatter available"
    echo "    Install one of: pip install ruff (recommended) | pip install black | pip install yapf"
  fi
}

# Format shell scripts (Google style: 2 spaces)
format_shell() {
  local file="${1:?Error: file required}"

  if has_command shfmt; then
    if [[ "${DRY_RUN}" == true ]]; then
      print_color blue "[DRY RUN] Would run shfmt on: $file"
    else
      echo -n "  → Running shfmt (2 spaces)... "
      shfmt -i 2 -bn -ci -w "$file"
      print_color green "✓"
    fi
  else
    print_color yellow "  ⚠ Skipping shell formatting (shfmt not found)"
    echo "    Install with: $(platform_command 'brew install shfmt' 'go install mvdan.cc/sh/v3/cmd/shfmt@latest')"
  fi
}

# Format Lua files (2 spaces)
format_lua() {
  local file="${1:?Error: file required}"

  if has_command stylua; then
    if [[ "${DRY_RUN}" == true ]]; then
      print_color blue "[DRY RUN] Would run stylua on: $file"
    else
      echo -n "  → Running stylua (2 spaces)... "
      # Create temporary config
      local tmp_config
      tmp_config=$(create_temp_dir)/stylua.toml
      cat > "${tmp_config}" << EOF
indent_type = "Spaces"
indent_width = 2
column_width = 80
EOF
      stylua --config-path "${tmp_config}" "$file"
      rm -f "${tmp_config}"
      print_color green "✓"
    fi
  else
    print_color yellow "  ⚠ Skipping Lua formatting (stylua not found)"
    echo "    Install with: $(platform_command 'brew install stylua' 'cargo install stylua')"
  fi
}

# Format with Prettier (Google style: 2 spaces, 80 column)
format_prettier() {
  local file="${1:?Error: file required}"
  local cmd=""

  if has_command prettierd; then
    cmd="prettierd"
  elif has_command prettier; then
    cmd="prettier"
  else
    print_color yellow "  ⚠ Skipping prettier formatting"
    echo "    Install with: npm install -g prettier"
    return
  fi

  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "[DRY RUN] Would run ${cmd} on: $file"
  else
    echo -n "  → Running ${cmd}... "
    ${cmd} --write \
      --tab-width 2 \
      --print-width 80 \
      --single-quote \
      --trailing-comma none \
      --arrow-parens avoid \
      "$file" 2>/dev/null
    print_color green "✓"
  fi
}

# Apply formatters based on file type
apply_formatters() {
  local file="${1:?Error: file required}"
  local ext="${file##*.}"
  local basename="$(basename "$file")"

  # Skip binary files
  if is_binary_file "$file"; then
    print_color yellow "  ⚠ Skipping binary file"
    return
  fi

  # Determine file type and apply formatter
  case "${ext}" in
    c|h)
      print_color blue "  ℹ Detected: C"
      format_cpp "$file"
      ;;
    cpp|cc|cxx|hpp|hxx)
      print_color blue "  ℹ Detected: C++"
      format_cpp "$file"
      ;;
    py|pyw|pyi)
      print_color blue "  ℹ Detected: Python"
      format_python "$file"
      ;;
    sh|bash)
      print_color blue "  ℹ Detected: Shell"
      format_shell "$file"
      ;;
    lua)
      print_color blue "  ℹ Detected: Lua"
      format_lua "$file"
      ;;
    js|jsx|ts|tsx|json|yaml|yml|html|css|scss|md)
      print_color blue "  ℹ Detected: ${ext} (Prettier)"
      format_prettier "$file"
      ;;
    *)
      # Check shebang for shell scripts
      if [[ -x "$file" ]] && head -n1 "$file" | grep -q "^#!/.*sh"; then
        print_color blue "  ℹ Detected: Shell (shebang)"
        format_shell "$file"
      else
        print_color yellow "  ⚠ Unknown file type: .${ext}"
      fi
      ;;
  esac
}

# Process a single file
process_file() {
  local file="${1:?Error: file required}"

  if [[ ! -f "$file" ]]; then
    print_color red "File not found: $file"
    return 1
  fi

  echo
  print_color blue "━━━ Processing: $file ━━━"

  # Apply operations
  if [[ "${DO_TRAILING}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    remove_trailing_whitespace "$file"
  fi

  if [[ "${DO_TABS}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    convert_tabs_to_spaces "$file"
  fi

  if [[ "${DO_QUOTES}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    normalize_quotes "$file"
  fi

  if [[ "${DO_FORMATTERS}" == true ]] || [[ "${DO_ALL}" == true ]]; then
    apply_formatters "$file"
  fi
}

# Show usage
usage() {
  cat << EOF
Usage: $(basename "$0") [OPTIONS] [FILES...]

Universal code formatter with Google style standards.
Works on both macOS and Linux.

OPTIONS:
  -h, --help          Show this help
  -a, --all           Apply all operations (default)
  -t, --trailing      Remove trailing whitespace
  -T, --tabs          Convert tabs to spaces
  -q, --quotes        Normalize smart quotes
  -f, --formatters    Apply language formatters
  -n, --dry-run       Show what would be done
  -v, --verbose       Verbose output

SUPPORTED LANGUAGES:
  C/C++      : clang-format (Google style, 2 spaces)
  Python     : ruff/black/yapf (Google style, 4 spaces)
  Shell      : shfmt (Google style, 2 spaces)
  Lua        : stylua (2 spaces)
  Web/Config : prettier (Google style, 2 spaces)

EXAMPLES:
  format                    # Format all tracked files
  format main.cpp          # Format single file
  format -t *.py          # Remove trailing whitespace
  format -n --all         # Dry run

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage
      exit 0
      ;;
    -a|--all)
      DO_ALL=true
      shift
      ;;
    -t|--trailing)
      DO_TRAILING=true
      shift
      ;;
    -T|--tabs)
      DO_TABS=true
      shift
      ;;
    -q|--quotes)
      DO_QUOTES=true
      shift
      ;;
    -f|--formatters)
      DO_FORMATTERS=true
      shift
      ;;
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    -n|--dry-run)
      DRY_RUN=true
      shift
      ;;
    -*)
      print_color red "Unknown option: $1"
      usage
      exit 1
      ;;
    *)
      FILES+=("$1")
      shift
      ;;
  esac
done

# Default to all operations if none specified
if [[ "${DO_TRAILING}" == false ]] && [[ "${DO_TABS}" == false ]] && \
   [[ "${DO_QUOTES}" == false ]] && [[ "${DO_FORMATTERS}" == false ]]; then
  DO_ALL=true
fi

# If no files specified, use git tracked files
if [[ ${#FILES[@]} -eq 0 ]]; then
  if git rev-parse --git-dir > /dev/null 2>&1; then
    print_color blue "No files specified, formatting all tracked files..."
    mapfile -t FILES < <(git ls-files)
  else
    print_color red "No files specified and not in a git repository"
    exit 1
  fi
fi

# Main execution
main() {
  local processed=0
  local failed=0

  for file in "${FILES[@]}"; do
    if [[ -e "$file" ]]; then
      if [[ -d "$file" ]]; then
        # Process directory
        while IFS= read -r -d '' f; do
          if process_file "$f"; then
            ((processed++))
          else
            ((failed++))
          fi
        done < <(find "$file" -type f -print0)
      else
        # Process file
        if process_file "$file"; then
          ((processed++))
        else
          ((failed++))
        fi
      fi
    else
      # Handle glob patterns
      local found=false
      for f in $file; do
        if [[ -f "$f" ]]; then
          found=true
          if process_file "$f"; then
            ((processed++))
          else
            ((failed++))
          fi
        fi
      done

      if [[ "${found}" == false ]]; then
        print_color yellow "No files match: $file"
      fi
    fi
  done

  # Summary
  echo
  print_color blue "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  if [[ "${DRY_RUN}" == true ]]; then
    print_color blue "📋 DRY RUN COMPLETE"
    echo "   Would process: ${processed} files"
  else
    print_color green "✅ FORMATTING COMPLETE"
    echo "   Processed: ${processed} files"
  fi

  if [[ ${failed} -gt 0 ]]; then
    print_color red "   Failed: ${failed} files"
    exit 1
  fi
}

main "$@"
