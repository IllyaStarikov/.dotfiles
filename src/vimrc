"
" .vimrc
" .dotfiles
"
" Created by Illya Starikov on March 5th, 2017
" Copyright 2017. Illya Starikov. All rights reserved.
"
" NOTE: This only works in Neovim, not Vim.
"

" Table of Contents
" 1  .................... Plugins
" 2  .................... General
" 3  .................... User Interface
" 4  .................... Autocomplete/Snippets/Linting
" 5  .................... Airline
" 6  .................... Skeleton Files
" 7  .................... Key Mappings
" 8  .................... Leader Key
" 9  .................... Code Runner
" 10 .................... FZF
" 11 .................... Functions
" 12 .................... Work-specific overrides
" 13 .................... LSP

let g:vimrc_type = 'personal' " options are: work / personal

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 1. Plugins
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
call plug#begin('~/.vim/plugged')

if has('macunix')                               " macOS
    " Plug '/usr/local/opt/fzf'
    Plug 'junegunn/fzf'
    Plug 'junegunn/fzf.vim'
else                                            " linux. I have no idea why another install
    Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
endif

Plug 'airblade/vim-gitgutter'                  " UI/UX For code
Plug 'dracula/vim', { 'as': 'dracula' }
Plug 'cocopon/iceberg.vim'
Plug 'projekt0n/github-nvim-theme'
Plug 'tpope/vim-fugitive'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
                                                " Language specific code
Plug 'illyastarikov/skeleton-files'
Plug 'justinmk/vim-syntax-extra'
Plug 'keith/swift.vim', { 'for': 'swift' }

" LSP and completion plugins
Plug 'neovim/nvim-lspconfig'                    " Core LSP configurations for Neovim
Plug 'williamboman/mason.nvim'                  " LSP/DAP installer UI
Plug 'williamboman/mason-lspconfig.nvim'        " Bridge Mason with lspconfig

" Autocompletion plugins (nvim-cmp and sources)
Plug 'hrsh7th/nvim-cmp'                         " Completion engine plugin
Plug 'hrsh7th/cmp-nvim-lsp'                     " LSP source for nvim-cmp
Plug 'hrsh7th/cmp-buffer'                       " Buffer word completion source
Plug 'hrsh7th/cmp-path'                         " File path completion source
Plug 'L3MON4D3/LuaSnip'                         " Snippet engine
Plug 'saadparwaiz1/cmp_luasnip'                 " Snippet completions source
Plug 'rafamadriz/friendly-snippets'             " Ready-made snippets
Plug 'onsails/lspkind-nvim'                     " Icons for completion menu

Plug 'vim-pandoc/vim-pandoc-syntax'

Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() } }
Plug 'illyastarikov/vim-snippets'               " Write code
Plug 'junegunn/vim-easy-align'
Plug 'skywind3000/asyncrun.vim'
Plug 'tommcdo/vim-lion'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'
Plug 'wellle/targets.vim'

Plug 'dense-analysis/ale'
" Plug 'pappasam/jedi-language-server'

Plug 'junegunn/fzf.vim'                         " Explore Code
Plug 'majutsushi/tagbar'
Plug 'mhinz/vim-grepper'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'xuyuanp/nerdtree-git-plugin'

call plug#end()

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 2. General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set history=250                                 " Sets how many lines of history VIM has to remember
set so=7                                        " Set 7 lines to the cursor - when moving vertically using j/k
set clipboard=unnamed                           " Yank to system clipboard by default
set backspace=indent,eol,start                  " Proper backspace

set autoread                                    " Set to auto read when a file is changed from the outside

set virtualedit=block                           " freedom of movement

set expandtab                                   " tabs => spaces
set shiftwidth=2                                " set number of spaces to 4
set tabstop=2                                   " if i has to use tabs, make it look like 4 spaces
set softtabstop=2                               " same as above idk

autocmd FileType python setlocal shiftwidth=2 tabstop=2 softtabstop=2

set smartindent                                 " autoindent on newlines
set autoindent                                  " copy indentation from previous lines
set linebreak                                   " word wrap like a sane human being
set conceallevel=0                              " don't try to conceal things

set list
set showbreak=↪\
set listchars=tab:→\ ,eol:↲,nbsp:␣,trail:•,extends:⟩,precedes:⟨

set number                                      " Show current line number
set relativenumber                              " Relative line numbers yo
set hlsearch                                    " Highlight searches

set nobackup                                    " Turn backup off
set nowb

let g:tex_flavor = "latex"                      " because the default is tex for some reason

augroup normalize                               " special rules to process files
    autocmd!
    autocmd FileType make,makefile set noexpandtab

    " If any file is in the blocklist, don't process these rules
    " Then, on every save, process this
    let blocklist = ['make', 'makefile', 'snippets', 'sh']
    autocmd BufWritePre * if index(blocklist, &ft) < 0 | :call TrimWhitespace()

    autocmd BufWritePre *.md :call NormalizeMarkdown()
augroup END

if has("mouse")                                 " Enable mouse support
    set mouse=a
endif

" if has('macunix')                               " For deoplete
"     let g:python3_host_prog = '/Users/starikov/.pyenv/shims/python' " macOS
" else
let g:python3_host_prog = '/usr/bin/python3'       " Linux
" endif

augroup projects                                " Treat headers as C
    autocmd!
    autocmd BufRead,BufNewFile *.h,*.c set filetype=c
augroup END

augroup nerdtreehelp
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
augroup END

let g:NERDTreeWinPos = "right"                  " NerdTree Stuff
let NERDTreeMapOpenInTab='\r'
let g:NERDTreeGitStatusWithFlags = 1

let g:ale_completion_enabled=1
let g:ale_python_pyls_executable = "pylsp"

" let g:ale_python_pyls_config = {
" \   'pylsp': {
" \     'plugins': {
" \       'pycodestyle': {
" \         'enabled': v:false,
" \       },
" \       'pyflakes': {
" \         'enabled': v:false,
" \       },
" \       'pydocstyle': {
" \         'enabled': v:true,
" \       },
" \     },
" \   },
" \}
                                                " Grep defaults
let grepper = {
    \ 'grep': {
    \     'grepprg': 'grep -Rn --color --exclude=\*.{o,exe,out,dll,obj} --exclude-dir=bin $*'
    \ }
\ }

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 3. User Interface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
syntax on                                       " Syntax highlighting
syntax enable
set spell spelllang=en_us                       " set english as standard language

set t_Co=256                                    " 256 colors for terminal

" Theme switching based on macOS appearance
if filereadable(expand("~/.config/theme-switcher/current-theme.sh"))
  let s:theme = substitute(system("source ~/.config/theme-switcher/current-theme.sh && echo $MACOS_THEME"), '\n', '', 'g')
  let s:variant = substitute(system("source ~/.config/theme-switcher/current-theme.sh && echo $MACOS_VARIANT"), '\n', '', 'g')
  let s:background = substitute(system("source ~/.config/theme-switcher/current-theme.sh && echo $MACOS_BACKGROUND"), '\n', '', 'g')

  if s:background == "dark"
    set background=dark
  else
    set background=light
  endif

  if s:theme == "default"
    if s:variant == "dark"
      colorscheme iceberg
      let g:airline_theme = 'dracula'
    else
      colorscheme iceberg
      let g:airline_theme = 'iceberg'
    endif
  elseif s:theme == "tron"
    if s:variant == "dark"
      colorscheme iceberg
      let g:airline_theme = 'iceberg'
    else
      colorscheme iceberg
      let g:airline_theme = 'iceberg'
    endif
  elseif s:theme == "write"
    if s:variant == "dark"
      colorscheme iceberg
      let g:airline_theme = 'iceberg'
    else
      colorscheme iceberg
      let g:airline_theme = 'iceberg'
    endif
  elseif s:theme == "github_light"
    colorscheme iceberg
    let g:airline_theme = 'sol'
  elseif s:theme == "github_light_default"
    colorscheme iceberg
    let g:airline_theme = 'sol'
  elseif s:theme == "github_light_high_contrast"
    colorscheme iceberg
    let g:airline_theme = 'sol'
  elseif s:theme == "github_light_colorblind"
    colorscheme iceberg
    let g:airline_theme = 'sol'
  elseif s:theme == "github_light_tritanopia"
    colorscheme iceberg
    let g:airline_theme = 'sol'
  elseif s:theme == "github_dark"
    colorscheme iceberg
    let g:airline_theme = 'base16_grayscale'
  elseif s:theme == "github_dark_default"
    colorscheme iceberg
    let g:airline_theme = 'base16_grayscale'
  elseif s:theme == "github_dark_dimmed"
    colorscheme iceberg
    let g:airline_theme = 'base16_grayscale'
  elseif s:theme == "github_dark_high_contrast"
    colorscheme iceberg
    let g:airline_theme = 'base16_grayscale'
  elseif s:theme == "github_dark_colorblind"
    colorscheme iceberg
    let g:airline_theme = 'base16_grayscale'
  elseif s:theme == "github_dark_tritanopia"
    colorscheme iceberg
    let g:airline_theme = 'base16_grayscale'
  else
    colorscheme iceberg
    let g:airline_theme = 'iceberg'
  endif
else
  " Default to dark theme
  set background=dark
  colorscheme iceberg
  let g:airline_theme = 'dracula'
endif

let g:dracula_italic = 1
let g:dracula_bold = 1
highlight Comment cterm=italic gui=italic

set cursorline!                                 " Turn on the cursorline
set guicursor=
" set synmaxcol=200                               " Don't syntax highlight after the 200th column

set magic                                       " For regular expressions

set ffs=unix,dos,mac                            " Use Unix as the standard file type

set wildmenu                                    " Use wild-menu
set wildmode=longest:list,full

set hidden                                      " Don't warn me about unsaved buffers

set noerrorbells                                " no annoying error noises
set novisualbell                                " or error visuals
set t_vb=
set tm=500

augroup syntax                                  " Syntax highlighting for latex/markdown as infinite
    autocmd!
    autocmd FileType tex,latex,markdown,pandoc set synmaxcol=2048

    autocmd BufNewFile,BufRead *.tex set syntax=tex
    autocmd BufNewFile,BufRead *.md set syntax=pandoc | set conceallevel=0
augroup END

augroup markdown_writing                        " Special configuration for markdown files
    autocmd!
    autocmd FileType markdown,pandoc setlocal wrap                " Enable word wrap
    autocmd FileType markdown,pandoc setlocal linebreak           " Break lines at word boundaries
    autocmd FileType markdown,pandoc setlocal nolist              " Hide special characters for cleaner view
    autocmd FileType markdown,pandoc setlocal textwidth=0         " No hard line breaks
    autocmd FileType markdown,pandoc setlocal wrapmargin=0        " No wrap margin
    autocmd FileType markdown,pandoc setlocal formatoptions-=t    " Don't auto-wrap text
    autocmd FileType markdown,pandoc setlocal formatoptions+=l    " Don't break long lines in insert mode
    autocmd FileType markdown,pandoc setlocal display+=lastline   " Show partial wrapped lines
    autocmd FileType markdown,pandoc setlocal breakindent         " Indent wrapped lines
    autocmd FileType markdown,pandoc setlocal breakindentopt=shift:2,min:40
    
    " Font settings for GUI vim (like MacVim or gvim)
    if has("gui_running")
        autocmd FileType markdown,pandoc setlocal guifont=Verdana:h14
    endif
    
    " Make the environment more comfortable for writing
    autocmd FileType markdown,pandoc setlocal spell                " Enable spell check
    autocmd FileType markdown,pandoc setlocal nonumber            " Hide line numbers
    autocmd FileType markdown,pandoc setlocal norelativenumber    " Hide relative line numbers
    autocmd FileType markdown,pandoc setlocal colorcolumn=        " Remove color column
    autocmd FileType markdown,pandoc setlocal signcolumn=no       " Hide sign column
    
    " Improved navigation for wrapped lines
    autocmd FileType markdown,pandoc nnoremap <buffer> j gj
    autocmd FileType markdown,pandoc nnoremap <buffer> k gk
    autocmd FileType markdown,pandoc nnoremap <buffer> 0 g0
    autocmd FileType markdown,pandoc nnoremap <buffer> $ g$
    autocmd FileType markdown,pandoc vnoremap <buffer> j gj
    autocmd FileType markdown,pandoc vnoremap <buffer> k gk
    autocmd FileType markdown,pandoc vnoremap <buffer> 0 g0
    autocmd FileType markdown,pandoc vnoremap <buffer> $ g$
augroup END

set list                                        " Show spaces, line breaks, the like
set showbreak=↪\
set listchars=tab:│·,trail:·,extends:→,extends:⟩,precedes:⟨

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 4. Autocomplete/Snippets/Linting
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:ale_python_flake8_options = "--max-line-length=200"
let g:ale_python_pylint_options = "--max-line-length=200 --errors-only"
set shortmess+=c


let g:ale_sign_error = '>>'                     " Cool >> for errors
let g:ale_sign_warning = '>'                    " and > for warnings

let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter% | %severity%][%code%] %s'

" autocmd BufWritePre *.py lua vim.lsp.buf.formatting_sync(nil, 100)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 5. Airline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:airline#extensions#whitespace#enabled = 0

set ttyfast

let g:airline_symbols_ascii = 1
let g:airline#extensions#ale#enabled = 1
let g:airline_detect_spell = 0
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#fnamemod = ':t'
let g:airline#extensions#tabline#tab_nr_type = 2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 6. Skeleton Files
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("autocmd")
    augroup templates
        autocmd!
        autocmd BufNewFile main.* silent! execute '0r ~/.vim/plugged/skeleton-files/skeleton-main.'.expand("<afile>:e")
        autocmd BufNewFile *.* silent! execute '0r ~/.vim/plugged/skeleton-files/skeleton.'.expand("<afile>:e")

        autocmd BufNewFile * %substitute#\[:VIM_EVAL:\]\(.\{-\}\)\[:END_EVAL:\]#\=eval(submatch(1))#ge
    augroup END
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 7. Key Mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Because I type Wq literally all the time
:command! W w
:command! Q q
:command! Wq wq

" Go up and down properly on wrapped text
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk

" Because I use word wrap
nnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
nnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
noremap  <buffer> <silent> 0 g0
noremap  <buffer> <silent> $ g$

" Because who needs arrow keys
noremap <up> <C-w><up>
noremap <down> <C-w><down>
noremap <left> <C-w><left>
noremap <right> <C-w><right>

" Buffers
nnoremap <Tab> :bnext<cr>
nnoremap <S-Tab> :bprevious<cr>

" ALE Errors
nmap <silent> [W <Plug>(ale_first)
nmap <silent> [w <Plug>(ale_previous)
nmap <silent> ]w <Plug>(ale_next)
nmap <silent> ]W <Plug>(ale_last)

nmap <C-]> :ALEGoToDefinition<CR>
nmap <C-\> :ALEFindReferences<CR>
nmap <C-[> :ALEHover<CR>

" Copy Filename
nmap ,cs :let @+=expand("%")<CR>
nmap ,cl :let @+=expand("%:p")<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 8. Leader Key
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let mapleader = "\<Space>"

nnoremap <leader>w :w<cr>
noremap <leader>q :q<cr>
noremap <leader>c :Kwbd<cr>
noremap <leader>x :x<cr>
nnoremap <leader>s <C-Z>
nnoremap <leader>d "_d

noremap <silent> <leader>n :NERDTreeToggle<cr>
noremap <leader>f :Files<cr>
noremap <leader>b :Buffers<cr>
noremap <leader>T :Tagbar<cr>
noremap <leader>g :Grepper -tool grep<cr>
nmap <leader><leader> v$h

nmap ga <Plug>(EasyAlign)
nnoremap <Leader>p :let @+=expand('%:p')<CR>

nnoremap <leader>t :terminal<cr> " fast opening of terminal
tnoremap <Esc> <C-\><C-n> " fast entering normal mode in terminal


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 9. Code Runner
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" I know this is garbage but this is my garbage.
function! RunCode(runCommand)
    if filereadable("makefile") || filereadable("Makefile")
        :execute 'AsyncRun make'
    else
        :execute 'AsyncRun ' a:runCommand
    endif
endfunction

augroup run
    autocmd!
    let windowopen = 1
    autocmd FileType tex,plaintex let windowopen = 0
    autocmd QuickFixCmdPost * call asyncrun#quickfix_toggle(8, windowopen)

    autocmd FileType python   nnoremap <buffer><leader>r :call RunCode("python3 %")<cr>
    autocmd FileType c        nnoremap <buffer><leader>r :call RunCode("clang *.c -o driver && ./driver")<cr>
    autocmd FileType cpp      nnoremap <buffer><leader>r :call RunCode("clang++ *.cpp -std=c++14 -o driver && ./driver")<cr>
    autocmd FileType tex      nnoremap <buffer><leader>r :call RunCode("latexmk")<cr>
    autocmd FileType plaintex nnoremap <buffer><leader>r :call RunCode("latexmk")<cr>
    autocmd FileType perl     nnoremap <buffer><leader>r :call RunCode("perl %")<cr>
    autocmd FileType sh       nnoremap <buffer><leader>r :call RunCode("bash %")<cr>
    autocmd FileType swift    nnoremap <buffer><leader>r :call RunCode("swift %") <cr>

    if has('macunix')
      autocmd FileType markdown nnoremap <buffer><leader>r :call RunCode("pandoc --standalone --from=markdown --to=rtf % \| pbcopy")<cr>
    else
      autocmd FileType markdown nnoremap <buffer><leader>r :call RunCode("pandoc % \| xclip -t text/html -selection clipboard")<cr>
    endif

    nnoremap <leader>R :Async<Up><CR>
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 10. FZF
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" This is the default extra key bindings
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit' }

" Default fzf layout
" - down / up / left / right
let g:fzf_layout = { 'down': '~40%' }

" Customize fzf colors to match your color scheme
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" Enable per-command history.
" CTRL-N and CTRL-P will be automatically bound to next-history and
" previous-history instead of down and up. If you don't like the change,
" explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
let g:fzf_history_dir = '~/.local/share/fzf-history'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 11. Functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! TrimWhitespace()
    let l:save = winsaveview()
    %s/\t/    /ge
    %s/\s\+$//ge
    call winrestview(l:save)
endfunction

function! NormalizeMarkdown()  " A bunch of regexes to make markdown happy
    let l:save = winsaveview()
    %s/’/'/ge
    %s/“/"/ge
    %s/“/"/ge
    %s/”/"/ge
    call winrestview(l:save)
endfunction


"delete the buffer; keep windows; create a scratch buffer if no buffers left
function! s:Kwbd(kwbdStage)
  if(a:kwbdStage == 1)
    if(!buflisted(winbufnr(0)))
      bd!
      return
    endif
    let s:kwbdBufNum = bufnr("%")
    let s:kwbdWinNum = winnr()
    windo call s:Kwbd(2)
    execute s:kwbdWinNum . 'wincmd w'
    let s:buflistedLeft = 0
    let s:bufFinalJump = 0
    let l:nBufs = bufnr("$")
    let l:i = 1
    while(l:i <= l:nBufs)
      if(l:i != s:kwbdBufNum)
        if(buflisted(l:i))
          let s:buflistedLeft = s:buflistedLeft + 1
        else
          if(bufexists(l:i) && !strlen(bufname(l:i)) && !s:bufFinalJump)
            let s:bufFinalJump = l:i
          endif
        endif
      endif
      let l:i = l:i + 1
    endwhile
    if(!s:buflistedLeft)
      if(s:bufFinalJump)
        windo if(buflisted(winbufnr(0))) | execute "b! " . s:bufFinalJump | endif
      else
        enew
        let l:newBuf = bufnr("%")
        windo if(buflisted(winbufnr(0))) | execute "b! " . l:newBuf | endif
      endif
      execute s:kwbdWinNum . 'wincmd w'
    endif
    if(buflisted(s:kwbdBufNum) || s:kwbdBufNum == bufnr("%"))
      execute "bd! " . s:kwbdBufNum
    endif
    if(!s:buflistedLeft)
      set buflisted
      set bufhidden=delete
      set buftype=
      setlocal noswapfile
    endif
  else
    if(bufnr("%") == s:kwbdBufNum)
      let prevbufvar = bufnr("#")
      if(prevbufvar > 0 && buflisted(prevbufvar) && prevbufvar != s:kwbdBufNum)
        b #
      else
        bn
      endif
    endif
  endif
endfunction

command! Kwbd call s:Kwbd(1)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 12. Work-specific overrides
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if vimrc_type == 'work'
    source ~/.vimrc.work
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => 13. LSP and Autocompletion Setup
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
lua << EOF
-- 1. Setup Mason (servers already installed via Homebrew)
require("mason").setup()
require("mason-lspconfig").setup({
    -- ensure_installed = { "pyright", "clangd", "marksman", "texlab", "lua_ls" }
    -- ^ commented out since servers are installed via Homebrew
})

-- 2. nvim-cmp setup for autocompletion
local cmp = require("cmp")
local luasnip = require("luasnip")
require("luasnip.loaders.from_vscode").lazy_load()  -- load friendly-snippets

cmp.setup({
  snippet = {
    expand = function(args)
      luasnip.lsp_expand(args.body)  -- expand snippet
    end,
  },
  mapping = {
    ["<CR>"] = cmp.mapping.confirm({ select = true }),         -- Enter to confirm selection
    ["<C-Space>"] = cmp.mapping.complete(),                    -- Ctrl+Space to manually trigger completion
    ["<Tab>"] = cmp.mapping(function(fallback)                 -- Tab to next item or snippet jump
        if cmp.visible() then cmp.select_next_item()
        elseif luasnip.expand_or_jumpable() then luasnip.expand_or_jump()
        else fallback() end
      end, { "i", "s" }),
    ["<S-Tab>"] = cmp.mapping(function(fallback)               -- Shift-Tab to previous item or snippet jump back
        if cmp.visible() then cmp.select_prev_item()
        elseif luasnip.jumpable(-1) then luasnip.jump(-1)
        else fallback() end
      end, { "i", "s" }),
  },
  sources = cmp.config.sources({
    { name = "nvim_lsp" },   -- LSP completions
    { name = "luasnip" },    -- Snippet completions
    { name = "buffer" },
    { name = "path" }
  }),
  formatting = {
    format = require("lspkind").cmp_format({ mode = "symbol_text", maxwidth = 50 })
    -- ^ lspkind to show icons in completion menu
  }
})

-- 3. LSP server configurations
local lspconfig = require("lspconfig")

-- Capabilities for nvim-cmp integration
local capabilities = require("cmp_nvim_lsp").default_capabilities()

-- Optional: on_attach function to bind keys after LSP attaches to buffer
local on_attach = function(client, bufnr)
  local buf = vim.lsp.buf    -- alias for convenience
  local map = function(mode, lhs, rhs, desc)
    if desc then desc = "[LSP] " .. desc end
    vim.keymap.set(mode, lhs, rhs, { buffer = bufnr, silent=true, noremap=true, desc = desc })
  end
  -- Keybindings for LSP features:
  map("n", "gd", buf.definition, "Go to definition")
  map("n", "gD", buf.declaration, "Go to declaration")
  map("n", "gi", buf.implementation, "Go to implementation")
  map("n", "gr", buf.references, "Find references")
  map("n", "K", buf.hover, "Hover documentation")
  map("n", "<F2>", buf.rename, "Rename symbol")
  map("n", "<F4>", buf.code_action, "Code actions")
  map("n", "gl", vim.diagnostic.open_float, "Show diagnostics")    -- Show diagnostics in floating window
  map("n", "[d", vim.diagnostic.goto_prev, "Prev diagnostic")
  map("n", "]d", vim.diagnostic.goto_next, "Next diagnostic")
end

-- Enable each language server:
lspconfig.pyright.setup{
    capabilities = capabilities,
    on_attach = on_attach
}
lspconfig.clangd.setup{
    capabilities = capabilities,
    on_attach = on_attach
}
lspconfig.marksman.setup{
    capabilities = capabilities,
    on_attach = on_attach
}
lspconfig.texlab.setup{
    capabilities = capabilities,
    on_attach = on_attach
}
lspconfig.lua_ls.setup{
    capabilities = capabilities,
    on_attach = on_attach,
    settings = {  -- example of how to configure a server (here, Lua LS)
      Lua = {
        diagnostics = { globals = {"vim"} },  -- recognize `vim` global
        workspace = { library = vim.api.nvim_list_runtime_paths() }
      }
    }
}
EOF

set completeopt-=preview

" Note: omni completion is now handled by nvim-cmp with LSP source
